# ========================================
# File: AggressiveResourceManager.h
# ========================================
#pragma once

#include "SystemResources.h"
#include <chrono>
#include <iostream>
#include <thread>
#include <functional>
#include <atomic>
#include <mutex>

/**
 * AggressiveResourceManager - A utility class for maximizing system resource usage
 * 
 * This class provides:
 * - Background monitoring of system resources
 * - Dynamic adjustment of thread count and batch sizes
 * - Automatic scaling based on workload patterns
 * - Forces the system to utilize available resources
 */
class AggressiveResourceManager {
public:
    AggressiveResourceManager(bool extremeMode = false) 
        : m_running(false), 
          m_extremeMode(extremeMode),
          m_memoryTarget(extremeMode ? 0.95f : 0.90f),
          m_cpuTarget(extremeMode ? 0.99f : 0.95f),
          m_currentThreads(std::thread::hardware_concurrency()),
          m_currentBatchSize(5000)
    {
        // Get system capabilities
        m_totalMemoryMB = SystemResources::getTotalMemoryMB();
        m_hardwareThreads = std::thread::hardware_concurrency();
        
        // Auto-tune based on system specs
        if (m_extremeMode) {
            // More aggressive tuning for extreme mode
            try {
                // Try to use the specialized methods if available
                m_memoryTarget = SystemResources::getAggressiveMemoryTarget();
                m_cpuTarget = SystemResources::getAggressiveCpuTarget();
            } catch(...) {
                // Fall back to hardcoded values if methods don't exist
                size_t totalMemoryMB = SystemResources::getTotalMemoryMB();
                unsigned int cores = SystemResources::getCpuCores();
                
                // Set memory target based on system memory
                if (totalMemoryMB > 32000) m_memoryTarget = 0.95f;
                else if (totalMemoryMB > 16000) m_memoryTarget = 0.92f;
                else if (totalMemoryMB > 8000) m_memoryTarget = 0.88f;
                else m_memoryTarget = 0.85f;
                
                // Set CPU target based on core count
                if (cores > 16) m_cpuTarget = 0.98f;
                else if (cores > 8) m_cpuTarget = 0.96f;
                else if (cores > 4) m_cpuTarget = 0.94f;
                else m_cpuTarget = 0.92f;
            }
            
            // Start with higher batch size in extreme mode
            if (m_totalMemoryMB > 32000) { // >32GB RAM
                m_currentBatchSize = 50000;
            } else if (m_totalMemoryMB > 16000) { // >16GB RAM
                m_currentBatchSize = 25000;
            } else if (m_totalMemoryMB > 8000) { // >8GB RAM
                m_currentBatchSize = 15000;
            }
        }
        
        std::cout << "[RESOURCE-MGR] Initialized with memory target: " << (m_memoryTarget * 100)
                  << "%, CPU target: " << (m_cpuTarget * 100) << "%" << std::endl;
    }
    
    ~AggressiveResourceManager() {
        stop();
    }
    
    // Start background monitoring thread
    void start() {
        if (m_running) return;
        
        m_running = true;
        m_monitorThread = std::thread(&AggressiveResourceManager::monitorLoop, this);
        
        std::cout << "[RESOURCE-MGR] Background resource monitoring started" << std::endl;
    }
    
    // Stop background monitoring
    void stop() {
        if (!m_running) return;
        
        m_running = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
    }
    
    // Register thread pool for auto-scaling
    void registerThreadPool(std::function<void(unsigned int)> scaleCallback) {
        std::lock_guard<std::mutex> lock(m_callbackMutex);
        m_threadScaleCallbacks.push_back(scaleCallback);
    }
    
    // Register batch size handler for auto-scaling
    void registerBatchSizeCallback(std::function<void(size_t)> batchCallback) {
        std::lock_guard<std::mutex> lock(m_callbackMutex);
        m_batchSizeCallbacks.push_back(batchCallback);
    }
    
    // Get optimal thread count for current system state
    unsigned int getOptimalThreadCount() const {
        unsigned int baseThreadCount = m_hardwareThreads;
        float cpuUsage = SystemResources::getCPUUtilization();
        
        // If using aggressive mode, use the aggressive version
        if (m_extremeMode) {
            return SystemResources::getAggressiveThreadCount(m_cpuTarget);
        }
        
        // If we're below target utilization, scale up threads
        if (cpuUsage < m_cpuTarget) {
            float availableRatio = (m_cpuTarget - cpuUsage) / m_cpuTarget;
            
            // Extreme mode: up to 8x hardware threads
            // Normal mode: up to 4x hardware threads
            float maxMultiplier = m_extremeMode ? 8.0f : 4.0f;
            float multiplier = 1.0f + (maxMultiplier - 1.0f) * availableRatio;
            
            return static_cast<unsigned int>(baseThreadCount * multiplier);
        } else {
            // Even when at/above target, keep at least hardware concurrency level
            return baseThreadCount;
        }
    }
    
    // Get optimal batch size for current memory state
    size_t getOptimalBatchSize(size_t rowSizeEstimateBytes = 500) const {
        // If using aggressive mode, use the aggressive version
        if (m_extremeMode) {
            return SystemResources::getAggressiveBatchSize(rowSizeEstimateBytes, m_memoryTarget);
        }
        
        size_t availableMemMB = SystemResources::getAvailableMemoryMB();
        float memoryUtilizationRatio = 1.0f - (static_cast<float>(availableMemMB) / m_totalMemoryMB);
        
        // Base batch size on total system memory
        size_t baseBatchSize;
        if (m_totalMemoryMB > 32000) { // >32GB RAM
            baseBatchSize = 25000;
        } else if (m_totalMemoryMB > 16000) { // >16GB RAM
            baseBatchSize = 15000;
        } else if (m_totalMemoryMB > 8000) { // >8GB RAM
            baseBatchSize = 10000;
        } else { // <8GB RAM
            baseBatchSize = 5000;
        }
        
        // If we're below target memory utilization, increase batch size
        if (memoryUtilizationRatio < m_memoryTarget) {
            float availableRatio = (m_memoryTarget - memoryUtilizationRatio) / m_memoryTarget;
            
            // Aggressive scaling - extreme mode: up to 20x base, normal: up to 10x base
            float maxMultiplier = m_extremeMode ? 20.0f : 10.0f;
            float multiplier = 1.0f + (maxMultiplier - 1.0f) * availableRatio;
            
            return static_cast<size_t>(baseBatchSize * multiplier);
        } else if (memoryUtilizationRatio > m_memoryTarget + 0.05f) {
            // If we're over target + buffer, decrease batch size
            float overuseRatio = (memoryUtilizationRatio - m_memoryTarget) / (1.0f - m_memoryTarget);
            
            // Scale down to minimum 20% of base
            float multiplier = std::max(0.2f, 1.0f - overuseRatio);
            
            return static_cast<size_t>(baseBatchSize * multiplier);
        } else {
            // Within target range, keep current base batch size
            return baseBatchSize;
        }
    }
    
    // Force CPU activity to increase utilization
    void forceCpuUtilization() {
        float currentCpuUsage = SystemResources::getCPUUtilization();
        
        // Only force utilization if we're significantly below target
        if (currentCpuUsage < m_cpuTarget * 0.8f) {
            // Launch specified number of busy threads that burn CPU
            unsigned int threadsToLaunch = static_cast<unsigned int>(
                (m_cpuTarget - currentCpuUsage) * m_hardwareThreads * 2.0f
            );
            
            if (threadsToLaunch > 0) {
                std::vector<std::thread> busyThreads;
                std::atomic<bool> stopBusy{false};
                
                for (unsigned int i = 0; i < threadsToLaunch; i++) {
                    busyThreads.emplace_back([&stopBusy](){
                        // Do meaningless work to consume CPU cycles
                        volatile double result = 0.0;
                        while (!stopBusy) {
                            for (int j = 0; j < 10000000; j++) {
                                result += std::sqrt(j * 1.0);
                            }
                        }
                    });
                }
                
                // Let them run for 100ms
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                
                // Stop busy threads
                stopBusy = true;
                for (auto& thread : busyThreads) {
                    thread.join();
                }
                
                std::cout << "[RESOURCE-MGR] Forced CPU utilization with " 
                          << threadsToLaunch << " busy threads" << std::endl;
            }
        }
    }

private:
    // Background monitor thread
    void monitorLoop() {
        // Monitor at different rates based on mode
        auto updateInterval = m_extremeMode ? 
            std::chrono::milliseconds(250) : std::chrono::milliseconds(500);
            
        while (m_running) {
            // Get current resource levels
            size_t availableMemMB = SystemResources::getAvailableMemoryMB();
            float memoryUtilizationRatio = 1.0f - (static_cast<float>(availableMemMB) / m_totalMemoryMB);
            float cpuUsage = SystemResources::getCPUUtilization();
            
            // Calculate optimal resources
            unsigned int optimalThreads = getOptimalThreadCount();
            size_t optimalBatchSize = getOptimalBatchSize();
            
            // Only update if significant changes
            bool shouldUpdateThreads = std::abs(static_cast<int>(optimalThreads) - 
                                             static_cast<int>(m_currentThreads)) > 2;
            
            bool shouldUpdateBatchSize = std::abs(static_cast<long>(optimalBatchSize) - 
                                               static_cast<long>(m_currentBatchSize)) > 
                                              (m_currentBatchSize / 4); // 25% change
            
            // Update threads if needed
            if (shouldUpdateThreads) {
                std::lock_guard<std::mutex> lock(m_callbackMutex);
                m_currentThreads = optimalThreads;
                
                for (auto& callback : m_threadScaleCallbacks) {
                    callback(optimalThreads);
                }
                
                std::cout << "[RESOURCE-MGR] Auto-scaled to " << optimalThreads 
                          << " threads (CPU: " << (cpuUsage * 100) << "%)" << std::endl;
            }
            
            // Update batch size if needed
            if (shouldUpdateBatchSize) {
                std::lock_guard<std::mutex> lock(m_callbackMutex);
                m_currentBatchSize = optimalBatchSize;
                
                for (auto& callback : m_batchSizeCallbacks) {
                    callback(optimalBatchSize);
                }
                
                std::cout << "[RESOURCE-MGR] Auto-scaled batch size to " << optimalBatchSize
                          << " (Memory: " << (memoryUtilizationRatio * 100) << "%)" << std::endl;
            }
            
            // In extreme mode, force utilization
            if (m_extremeMode && cpuUsage < m_cpuTarget * 0.85f) {
                forceCpuUtilization();
            }
            
            // Sleep until next update
            std::this_thread::sleep_for(updateInterval);
        }
    }
    
    // Configuration
    bool m_extremeMode;
    float m_memoryTarget;
    float m_cpuTarget;
    
    // System information
    size_t m_totalMemoryMB;
    unsigned int m_hardwareThreads;
    
    // Current settings
    unsigned int m_currentThreads;
    size_t m_currentBatchSize;
    
    // Thread management
    std::atomic<bool> m_running;
    std::thread m_monitorThread;
    
    // Callbacks for resource updates
    std::mutex m_callbackMutex;
    std::vector<std::function<void(unsigned int)>> m_threadScaleCallbacks;
    std::vector<std::function<void(size_t)>> m_batchSizeCallbacks;
};


# ========================================
# File: BatchProcessor.cpp
# ========================================
#include "BatchProcessor.h"
#include "DataStructures.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <functional>
#include <string>

// Remove all the functions that are duplicated in FileProcessing.cpp:
// processPatientsInBatches
// processConditionsInBatches
// processEncountersInBatches
// processMedicationsInBatches
// processObservationsInBatches

// For BatchProcessor class-related code, use the template implementations 
// in the BatchProcessor.h header instead


# ========================================
# File: BatchProcessor.h
# ========================================
#pragma once

#ifndef BATCH_PROCESSOR_H
#define BATCH_PROCESSOR_H

#include "DataStructures.h"
#include <string>
#include <vector>
#include <functional>
#include <fstream>
#include <unordered_map>
#include <iostream>
#include <filesystem>
#include "SystemResources.h"

// Only define BatchProcessor if it's not already defined in DataStructures.h
#ifndef BATCH_PROCESSOR_DEFINED
#define BATCH_PROCESSOR_DEFINED

// A memory-efficient batch processor for CSV files
class BatchProcessor {
public:
    template<typename T>
    static void processFile(const std::string &path, 
                          std::function<T(const std::vector<std::string>&, const std::vector<std::string>&)> rowToObj,
                          std::function<void(const T&)> callback,
                          size_t batchSize = 500) {
        std::ifstream file(path);
        if (!file.is_open()) {
            std::cerr << "[ERROR] Cannot open " << path << std::endl;
            return;
        }
        
        // Get file size and adapt batch size accordingly
        size_t fileSize = getFileSize(path);
        if (fileSize > 100 * 1024 * 1024) { // If file is larger than 100MB
            batchSize = adaptBatchSizeToFile(path, batchSize);
            std::cout << "[BATCH] Adjusted batch size to " << batchSize << " for large file: " << path << std::endl;
        }
        
        std::string line;
        std::getline(file, line);  // Read header
        
        // Split header into column names
        std::vector<std::string> header = splitCSV(line);
        
        std::vector<T> batch;
        batch.reserve(batchSize);
        
        size_t rowsProcessed = 0;
        while (std::getline(file, line)) {
            std::vector<std::string> values = splitCSV(line);
            
            // Skip empty or malformed rows
            if (values.size() < header.size() / 2) {
                continue;
            }
            
            // Convert row to object using callback
            T obj = rowToObj(header, values);
            
            batch.push_back(obj);
            rowsProcessed++;
            
            if (batch.size() >= batchSize) {
                // Process batch
                for (const auto &item : batch) {
                    callback(item);
                }
                batch.clear();
                batch.reserve(batchSize); // Ensure capacity is maintained
                
                // Every 1M rows, output progress
                if (rowsProcessed % 1000000 == 0) {
                    std::cout << "[PROGRESS] Processed " << rowsProcessed << " rows from " << path << std::endl;
                }
            }
        }
        
        // Process remaining items
        for (const auto &item : batch) {
            callback(item);
        }
    }
    
    static std::vector<std::string> splitCSV(const std::string &line) {
        std::vector<std::string> result;
        result.reserve(20); // Pre-allocate space for typical CSV columns
        std::string current;
        current.reserve(64); // Pre-allocate for efficiency
        bool inQuotes = false;
        
        for (char c : line) {
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                result.push_back(current);
                current.clear();
            } else {
                current += c;
            }
        }
        result.push_back(current);  // Add the last field
        return result;
    }
    
    // Process large files with adaptive batch sizing
    template<typename T>
    static void processLargeFile(
        const std::string &path,
        std::function<T(const std::vector<std::string>&, const std::vector<std::string>&)> rowToObj,
        std::function<void(const T&)> callback)
    {
        // Get optimal batch size based on file size and memory
        size_t optimalBatchSize = adaptBatchSizeToFile(path, 1000);
        processFile(path, rowToObj, callback, optimalBatchSize);
    }

private:
    static size_t getFileSize(const std::string& path) {
        std::filesystem::path fs_path(path);
        if (std::filesystem::exists(fs_path)) {
            return static_cast<size_t>(std::filesystem::file_size(fs_path));
        }
        return 0;
    }
    
    static size_t adaptBatchSizeToFile(const std::string& path, size_t defaultBatchSize) {
        size_t fileSize = getFileSize(path);
        if (fileSize == 0) return defaultBatchSize;
        
        // Use the file size to determine an appropriate batch size
        // For very large files, use larger batches for better efficiency
        if (fileSize > 1 * 1024 * 1024 * 1024) { // >1GB
            defaultBatchSize = defaultBatchSize * 10;
        } else if (fileSize > 100 * 1024 * 1024) { // >100MB
            defaultBatchSize = defaultBatchSize * 5;
        } else if (fileSize > 10 * 1024 * 1024) { // >10MB
            defaultBatchSize = defaultBatchSize * 2;
        }
        
        // Consider available memory - use up to 5% of available memory for batch
        size_t availableMemoryMB = SystemResources::getAvailableMemoryMB();
        size_t memoryBasedSize = (availableMemoryMB * 1024 * 1024 * 0.05) / 500; // Assume ~500 bytes per record
        
        // Check if extreme performance mode is active (this requires access to the global flag)
        bool extremeMode = false;
        try {
            // Try to detect if we're running in extreme mode by looking at memory utilization target
            if (SystemResources::getCPUUtilization() > 0.9f) {
                extremeMode = true;
            }
        } catch(...) {}
        
        // In extreme mode, be more aggressive with batch sizing
        if (extremeMode) {
            memoryBasedSize = memoryBasedSize * 2;
            defaultBatchSize = defaultBatchSize * 2;
        }
        
        // Return the capped batch size
        size_t result = std::max(defaultBatchSize, memoryBasedSize);
        
        // Put an upper cap on batch size to avoid memory issues
        return std::min(result, static_cast<size_t>(1000000));
    }
};

#endif // BATCH_PROCESSOR_DEFINED

#endif // BATCH_PROCESSOR_H


# ========================================
# File: BatchProcessorTuner.cpp
# ========================================
#include "BatchProcessorTuner.h"
#include <algorithm>

size_t BatchProcessorTuner::getOptimalBatchSize(size_t recordCount) {
    // Simple implementation - in a real system this would be more sophisticated
    return std::min(recordCount, static_cast<size_t>(1000));
}


# ========================================
# File: BatchProcessorTuner.h
# ========================================
#pragma once

#ifndef BATCH_PROCESSOR_TUNER_H
#define BATCH_PROCESSOR_TUNER_H

#include <cstddef>

class BatchProcessorTuner {
public:
    static size_t getOptimalBatchSize(size_t recordCount);
};

#endif // BATCH_PROCESSOR_TUNER_H


# ========================================
# File: DataStructures.cpp
# ========================================
#include "DataStructures.h"

// Initialize the static variable
unsigned int THREAD_COUNT = 4;

// Implementation of any DataStructures methods if needed
// Most are likely to be inline or header-only implementations

std::unordered_map<std::string, std::pair<double, double>> OBS_ABNORMAL_DIRECT = {
    {"Systolic Blood Pressure", {90.0, 140.0}},
    {"Diastolic Blood Pressure", {60.0, 90.0}},
    {"Heart Rate", {60.0, 100.0}},
    {"Glucose", {70.0, 126.0}},
    {"A1C", {4.0, 6.5}}
};


# ========================================
# File: DataStructures.h
# ========================================
#pragma once

#ifndef DATA_STRUCTURES_H
#define DATA_STRUCTURES_H

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <mutex>
#include <functional> // Add this to fix std::function error

// Forward declaration of external variables
extern unsigned int THREAD_COUNT;

// Patient record structure
struct PatientRecord {
    std::string Id;
    std::string Birthdate;  // Make sure this field exists
    std::string Deathdate;
    std::string SSN;
    std::string Drivers;
    std::string Passport;
    std::string Prefix;
    std::string First;
    std::string Last;
    std::string Suffix;
    std::string Maiden;
    std::string Gender;
    float CharlsonIndex = 0.0f;
    float ElixhauserIndex = 0.0f;
    float Comorbidity_Score = 0.0f;
    int Hospitalizations_Count = 0;
    int Medications_Count = 0;
    int Abnormal_Observations_Count = 0;
    float Health_Index = 0.0f;
    bool IsDeceased = false;
    std::string RaceCategory;
    std::string EthnicityCategory;
    std::string MaritalStatus;
    float HealthcareExpenses = 0.0f;
    float HealthcareCoverage = 0.0f;
    float Income = 0.0f;
    int Age = 0;  // Added Age field with default value
    std::string Marital_Status;
    std::string Race;
    std::string Ethnicity;
    float Healthcare_Coverage;
    float Healthcare_Expenses;
};

// Condition row structure
struct ConditionRow {
    std::string START;
    std::string STOP;
    std::string PATIENT;
    std::string ENCOUNTER; // Add this field
    std::string CODE;
    std::string DESCRIPTION;
};

// Encounter row structure
struct EncounterRow {
    std::string ID;       // Add this field
    std::string START;
    std::string STOP;
    std::string PATIENT;
    std::string ENCOUNTERCLASS;
};

// Medication row structure
struct MedicationRow {
    std::string START;
    std::string STOP;
    std::string PATIENT;
    std::string CODE;
    std::string DESCRIPTION;
};

// Observation row structure
struct ObservationRow {
    std::string DATE;
    std::string PATIENT;
    std::string CODE;
    std::string DESCRIPTION;
    std::string VALUE;
    std::string UNITS;
};

// Procedure row structure
struct ProcedureRow {
    std::string PATIENT;
    std::string ENCOUNTER;
    std::string CODE;
    std::string DESCRIPTION;
};

// Thread-safe counter for tracking patient metrics
class ThreadSafeCounter {
private:
    std::unordered_map<std::string, int> intCounts;
    std::unordered_map<std::string, float> floatCounts;
    std::mutex mutex;

public:
    void increment(const std::string& key, int amount = 1) {
        std::lock_guard<std::mutex> lock(mutex);
        intCounts[key] += amount;
    }

    void addFloat(const std::string& key, float value) {
        std::lock_guard<std::mutex> lock(mutex);
        floatCounts[key] += value;
    }

    int getInt(const std::string& key) const {
        auto it = intCounts.find(key);
        return (it != intCounts.end()) ? it->second : 0;
    }

    float getFloat(const std::string& key) const {
        auto it = floatCounts.find(key);
        return (it != floatCounts.end()) ? it->second : 0.0f;
    }
    
    // Added for debugging - access to internal maps
    const std::unordered_map<std::string, int>& internalMap() const {
        return intCounts;
    }
    
    const std::unordered_map<std::string, float>& internalFloatMap() const {
        return floatCounts;
    }
};

// External variable declarations
extern unsigned int THREAD_COUNT;
extern std::unordered_map<std::string, std::pair<double, double>> OBS_ABNORMAL_DIRECT;

// Mark BatchProcessor as defined
#define BATCH_PROCESSOR_DEFINED
class BatchProcessor {
public:
    template<typename T>
    static void processFile(
        const std::string& filePath,
        std::function<T(const std::vector<std::string>&, const std::vector<std::string>&)> parser,
        std::function<void(const T&)> callback
    ) {
        // Implementation omitted for brevity
    }
};

#endif // DATA_STRUCTURES_H


# ========================================
# File: debug_patient_data.cpp
# ========================================
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <chrono>
#include <filesystem>
#include "DataStructures.h"
#include "FileProcessing.h"
#include "MedicalDictionaries.h"

namespace fs = std::filesystem;

// Function to save debug info about patients, conditions, etc.
void saveDebugInfo(const std::string& outputFile) {
    std::cout << "[INFO] Running debug data extraction to " << outputFile << std::endl;
    
    // Initialize dictionaries
    initializeDirectLookups();
    initializeElixhauserLookups();
    initializeObsAbnormalDirect();
    
    // First, locate the data files
    std::vector<std::string> patientFiles;
    std::vector<std::string> condFiles;
    std::vector<std::string> encFiles;
    std::vector<std::string> medFiles;
    std::vector<std::string> obsFiles;
    
    // Search in the Data directory
    fs::path dataDir = "Data";
    if (fs::exists(dataDir)) {
        for (const auto& entry : fs::directory_iterator(dataDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".csv") {
                std::string filename = entry.path().filename().string();
                if (filename.find("patients") != std::string::npos) {
                    patientFiles.push_back(entry.path().string());
                }
                else if (filename.find("conditions") != std::string::npos) {
                    condFiles.push_back(entry.path().string());
                }
                else if (filename.find("encounters") != std::string::npos) {
                    encFiles.push_back(entry.path().string());
                }
                else if (filename.find("medications") != std::string::npos) {
                    medFiles.push_back(entry.path().string());
                }
                else if (filename.find("observations") != std::string::npos) {
                    obsFiles.push_back(entry.path().string());
                }
            }
        }
    }
    
    std::cout << "[INFO] Found " << patientFiles.size() << " patient files" << std::endl;
    std::cout << "[INFO] Found " << condFiles.size() << " condition files" << std::endl;
    std::cout << "[INFO] Found " << encFiles.size() << " encounter files" << std::endl;
    std::cout << "[INFO] Found " << medFiles.size() << " medication files" << std::endl;
    std::cout << "[INFO] Found " << obsFiles.size() << " observation files" << std::endl;
    
    // Load patients
    std::vector<PatientRecord> allPatients;
    for (const auto& pFile : patientFiles) {
        processPatientsInBatches(pFile, [&](const PatientRecord& p) {
            allPatients.push_back(p);
        });
    }
    std::cout << "[INFO] Loaded " << allPatients.size() << " patient records" << std::endl;
    
    // Setup counters
    ThreadSafeCounter charlsonCounter;
    ThreadSafeCounter elixhauserCounter;
    ThreadSafeCounter hospitalCounter;
    ThreadSafeCounter medsCounter;
    ThreadSafeCounter abnormalObsCounter;
    
    // Process conditions
    std::vector<ConditionRow> allConditions;
    for (const auto& cFile : condFiles) {
        processConditionsInBatches(cFile, [&](const ConditionRow& c) {
            allConditions.push_back(c);
            
            // Find Charlson weights
            auto charlsonIt = CHARLSON_CODE_TO_WEIGHT.find(c.CODE);
            if (charlsonIt != CHARLSON_CODE_TO_WEIGHT.end()) {
                charlsonCounter.addFloat(c.PATIENT, charlsonIt->second);
            }
            
            // Find Elixhauser weights
            auto elixhauserIt = ELIXHAUSER_CODE_TO_WEIGHT.find(c.CODE);
            if (elixhauserIt != ELIXHAUSER_CODE_TO_WEIGHT.end()) {
                elixhauserCounter.addFloat(c.PATIENT, elixhauserIt->second);
            }
            
            // Also try lowercase description matching
            std::string lowerDesc = c.DESCRIPTION;
            std::transform(lowerDesc.begin(), lowerDesc.end(), lowerDesc.begin(), 
                           [](unsigned char ch) { return std::tolower(ch); });
                           
            // Check for keywords in description
            if (lowerDesc.find("diabetes") != std::string::npos) {
                charlsonCounter.addFloat(c.PATIENT, 1.0f);
                elixhauserCounter.addFloat(c.PATIENT, 0.5f);
            }
            if (lowerDesc.find("heart failure") != std::string::npos) {
                charlsonCounter.addFloat(c.PATIENT, 1.0f);
                elixhauserCounter.addFloat(c.PATIENT, 1.5f);
            }
        });
    }
    
    // Process encounters
    for (const auto& eFile : encFiles) {
        processEncountersInBatches(eFile, [&](const EncounterRow& e) {
            if (e.ENCOUNTERCLASS == "inpatient") {
                hospitalCounter.increment(e.PATIENT);
            }
        });
    }
    
    // Process medications
    for (const auto& mFile : medFiles) {
        processMedicationsInBatches(mFile, [&](const MedicationRow& m) {
            medsCounter.increment(m.PATIENT);
        });
    }
    
    // Process observations
    for (const auto& oFile : obsFiles) {
        processObservationsInBatches(oFile, [&](const ObservationRow& o) {
            try {
                double value = std::stod(o.VALUE);
                if (isAbnormalObsFast(o.DESCRIPTION, value)) {
                    abnormalObsCounter.increment(o.PATIENT);
                }
            } catch (...) {
                // Non-numeric value, ignore
            }
        });
    }
    
    // Update patient records
    for (auto& p : allPatients) {
        p.CharlsonIndex = charlsonCounter.getFloat(p.Id);
        p.ElixhauserIndex = elixhauserCounter.getFloat(p.Id);
        p.Hospitalizations_Count = hospitalCounter.getInt(p.Id);
        p.Medications_Count = medsCounter.getInt(p.Id);
        p.Abnormal_Observations_Count = abnormalObsCounter.getInt(p.Id);
    }
    
    // Save debug file
    std::ofstream outFile(outputFile);
    if (!outFile.is_open()) {
        std::cerr << "[ERROR] Failed to open output file: " << outputFile << std::endl;
        return;
    }
    
    outFile << "PatientId,CharlsonIndex,ElixhauserIndex,Hospitalizations,Medications,AbnormalObs\n";
    for (const auto& p : allPatients) {
        outFile << p.Id << "," 
                << p.CharlsonIndex << "," 
                << p.ElixhauserIndex << "," 
                << p.Hospitalizations_Count << "," 
                << p.Medications_Count << "," 
                << p.Abnormal_Observations_Count << "\n";
    }
    
    outFile.close();
    std::cout << "[INFO] Debug info saved to " << outputFile << std::endl;
    
    // Print summary
    int countNonZeroCharlson = 0;
    int countNonZeroElixhauser = 0;
    int countNonZeroHosp = 0;
    int countNonZeroMeds = 0;
    int countNonZeroObs = 0;
    
    for (const auto& p : allPatients) {
        if (p.CharlsonIndex > 0) countNonZeroCharlson++;
        if (p.ElixhauserIndex > 0) countNonZeroElixhauser++;
        if (p.Hospitalizations_Count > 0) countNonZeroHosp++;
        if (p.Medications_Count > 0) countNonZeroMeds++;
        if (p.Abnormal_Observations_Count > 0) countNonZeroObs++;
    }
    
    std::cout << "[SUMMARY] Patients with non-zero values:" << std::endl;
    std::cout << "  Charlson Index: " << countNonZeroCharlson << " of " << allPatients.size() << std::endl;
    std::cout << "  Elixhauser Index: " << countNonZeroElixhauser << " of " << allPatients.size() << std::endl;
    std::cout << "  Hospitalizations: " << countNonZeroHosp << " of " << allPatients.size() << std::endl;
    std::cout << "  Medications: " << countNonZeroMeds << " of " << allPatients.size() << std::endl;
    std::cout << "  Abnormal Observations: " << countNonZeroObs << " of " << allPatients.size() << std::endl;
}

int main() {
    std::cout << "Running patient data debug tool..." << std::endl;
    saveDebugInfo("patient_debug.csv");
    return 0;
}


# ========================================
# File: FastCSVReader.h
# ========================================
#pragma once

#include <string>
#include <vector>
#include <functional>
#include <fstream>
#include <memory>
#include <algorithm>
#include <iostream>

/**
 * FastCSVReader - Optimized CSV reader with batched processing
 * 
 * Features:
 * - Uses large buffer for improved I/O performance
 * - Processes rows in batches to reduce memory allocations
 * - Direct string manipulation for faster CSV parsing
 * - Memory-friendly string handling
 */
class FastCSVReader {
private:
    std::ifstream file;
    std::vector<char> buffer;
    size_t buffer_size;
    static constexpr size_t DEFAULT_BUFFER_SIZE = 1024 * 1024; // 1MB buffer

public:
    FastCSVReader(const std::string& path, size_t buffer_size = DEFAULT_BUFFER_SIZE) 
        : buffer_size(buffer_size) {
        file.open(path, std::ios::binary);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + path);
        }
        buffer.resize(buffer_size);
    }
    
    // Fast CSV string splitting without using stringstream
    static std::vector<std::string> splitCSV(const char* line, size_t length) {
        std::vector<std::string> result;
        result.reserve(20); // Typical number of columns in medical data
        
        const char* start = line;
        bool inQuotes = false;
        
        for (size_t i = 0; i < length; i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                result.push_back(std::string(start, line + i - start));
                start = line + i + 1;
            }
        }
        
        // Add the last field
        result.push_back(std::string(start, line + length - start));
        return result;
    }
    
    // Overload for std::string
    static std::vector<std::string> splitCSV(const std::string& line) {
        return splitCSV(line.c_str(), line.length());
    }
    
    // Read header line
    std::vector<std::string> readHeader() {
        std::string line;
        std::getline(file, line);
        return splitCSV(line);
    }
    
    // Read the file in batches with callback for each batch
    template<typename T>
    void readBatches(
        std::function<T(const std::vector<std::string>&, const std::vector<std::string>&)> rowToObj,
        std::function<void(const std::vector<T>&)> processBatch,
        size_t batch_size = 2000
    ) {
        std::vector<T> batch;
        batch.reserve(batch_size);
        
        std::string line;
        std::vector<std::string> header = readHeader();
        
        while (std::getline(file, line)) {
            try {
                std::vector<std::string> values = splitCSV(line);
                
                // Convert row to object and add to batch
                T obj = rowToObj(header, values);
                batch.push_back(std::move(obj));
                
                if (batch.size() >= batch_size) {
                    processBatch(batch);
                    batch.clear();
                    batch.reserve(batch_size);
                }
            } catch (const std::exception& e) {
                std::cerr << "[WARN] Error processing CSV row: " << e.what() << std::endl;
                // Continue with next row
            }
        }
        
        // Process remaining items
        if (!batch.empty()) {
            processBatch(batch);
        }
    }
    
    bool isOpen() const {
        return file.is_open();
    }
    
    ~FastCSVReader() {
        if (file.is_open()) {
            file.close();
        }
    }
};


# ========================================
# File: FeatureUtils.cpp
# ========================================
#include "FeatureUtils.h"
#include "DataStructures.h"
#include "FileProcessing.h"  // Add this include for normalizeFieldName
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <sstream>
#include <unordered_map>
#include <iomanip>  // For std::setprecision

// Function to get exact features needed by the TabNet model
std::vector<std::string> getModelExpectedFeatures() {
    // Include all columns required by run_patient_group_predictions.py
    return {
        "Id",  // Case-sensitive match
        "AGE", // Python uses uppercase
        "GENDER",
        "RACE",
        "ETHNICITY", 
        "MARITAL",
        "HEALTHCARE_EXPENSES",
        "HEALTHCARE_COVERAGE", 
        "INCOME",
        "CharlsonIndex",         // These next lines were previously missing
        "ElixhauserIndex",       // in the implementation
        "Comorbidity_Score",
        "Hospitalizations_Count",
        "Medications_Count",
        "Abnormal_Observations_Count",
        "DECEASED",
        "Health_Index"           // Critical for scaling 
    };
}

// Function to validate feature CSV has correct format
bool validateFeatureCSV(const std::string& csvPath) {
    std::ifstream file(csvPath);
    if (!file.is_open()) {
        std::cerr << "[ERROR] Could not open feature CSV for validation: " << csvPath << std::endl;
        return false;
    }
    
    // Read header
    std::string header;
    std::getline(file, header);
    
    // Get expected headers
    auto expectedFeatures = getModelExpectedFeatures();
    
    // Parse the header
    std::vector<std::string> csvColumns;
    std::istringstream headerStream(header);
    std::string column;
    while (std::getline(headerStream, column, ',')) {
        // Trim whitespace
        column.erase(0, column.find_first_not_of(" \t\r\n"));
        column.erase(column.find_last_not_of(" \t\r\n") + 1);
        csvColumns.push_back(column);
    }
    
    // Check if all expected features are present (case insensitive)
    bool valid = true;
    for (const auto& feature : expectedFeatures) {
        std::string featureLower = toLowercase(feature);
        bool found = false;
        for (const auto& csvCol : csvColumns) {
            if (toLowercase(csvCol) == featureLower) {
                found = true;
                break;
            }
        }
        
        if (!found) {
            std::cerr << "[ERROR] Missing required feature in CSV: " << feature << std::endl;
            valid = false;
        }
    }
    
    // Check column data types (sample first few rows)
    int rowCount = 0;
    std::string line;
    while (std::getline(file, line) && rowCount < 5) {
        rowCount++;
        // Here you could add checks for data types by column index
        // but at minimum log the data for debugging
        std::cout << "[DEBUG] Row " << rowCount << ": " << line << std::endl;
    }
    
    if (!valid) {
        // If validation fails, try to fix it automatically
        std::cout << "[INFO] Attempting to fix feature CSV using Python helper...\n";
        std::string fixCmd = "python feature_validator.py \"" + csvPath + "\" \"" + csvPath + "\"";
        int fixResult = std::system(fixCmd.c_str());
        if (fixResult == 0) {
            std::cout << "[INFO] Fixed feature CSV format issues\n";
            valid = true;
        }
    }
    
    std::cout << "[INFO] Feature CSV validation: " << (valid ? "PASSED" : "FAILED") << std::endl;
    return valid;
}

// Export patient records to match Python's expected format
void writeFeaturesCSV(
    const std::vector<PatientRecord>& patients,
    const std::string& outputPath,
    const std::vector<std::string>& featureCols
) {
    std::ofstream outFile(outputPath);
    if (!outFile.is_open()) {
        std::cerr << "[ERROR] Could not open file for writing: " << outputPath << std::endl;
        return;
    }
    
    // Write header - exact column names as specified in featureCols
    for (size_t i = 0; i < featureCols.size(); ++i) {
        outFile << featureCols[i];
        if (i < featureCols.size() - 1) outFile << ",";
    }
    outFile << "\n";
    
    // These mappings are based on exact models' embedding dimensions
    // Each model has specific expectations for categorical columns:
    // 
    // TabNet Categorical Mappings (from model_inspector):
    // Index 1: MARITAL - values 0-1  (input_dim=2)
    // Index 2: RACE - values 0-1     (input_dim=2)
    // Index 3: ETHNICITY - values 0-5 (input_dim=6)
    // Index 4: GENDER - values 0-1   (input_dim=2)
    // Index 5: HEALTHCARE_COVERAGE - values 0-4 (input_dim=5)
    
    // Map for gender - must be 0 or 1 only
    std::unordered_map<std::string, int> genderMap = {
        {"M", 1}, {"F", 0},
        {"male", 1}, {"female", 0},
        {"MALE", 1}, {"FEMALE", 0},
        {"m", 1}, {"f", 0}
    };
    
    // Map for marital status - must be 0 or 1 only
    std::unordered_map<std::string, int> maritalMap = {
        {"S", 0}, {"SINGLE", 0},
        {"M", 1}, {"MARRIED", 1},
        {"W", 0}, {"WIDOWED", 0}, // Changed to 0 for safety
        {"D", 0}, {"DIVORCED", 0}  
    };
    
    // Map race - must be 0 or 1 only for diabetes model
    std::unordered_map<std::string, int> raceMap = {
        {"white", 0},
        {"black", 0}, // Changed to 0
        {"asian", 0}, // Changed to 0
        {"native", 1}, // Changed to 1
        {"other", 1}  // Changed to 1
    };
    
    // Map ethnicity - must be 0-5 
    std::unordered_map<std::string, int> ethnicityMap = {
        {"hispanic", 0},
        {"nonhispanic", 1},
        {"other", 2}  // Values should be 0-5
    };
    
    // Write data
    int skippedRows = 0;
    for (const auto& patient : patients) {
        std::string row = "";
        bool skipRow = false;
        
        // Process each feature in the exact order specified
        for (const auto& feature : featureCols) {
            if (feature == "Id") {
                row += patient.Id;
            }
            else if (feature == "AGE") {
                row += std::to_string(patient.Age);
            }
            else if (feature == "MARITAL") {
                // Convert to integer code expected by model - MUST be 0 or 1 only
                std::string status = patient.Marital_Status;
                std::transform(status.begin(), status.end(), status.begin(), ::toupper);
                auto it = maritalMap.find(status);
                int maritalCode = 0; // Default to 0
                if (it != maritalMap.end()) {
                    maritalCode = it->second;
                }
                // Safety check - embedding dimension is 2 (values can only be 0 or 1)
                if (maritalCode > 1) maritalCode = 0;
                row += std::to_string(maritalCode);
            }
            else if (feature == "RACE") {
                std::string race = patient.Race;
                std::transform(race.begin(), race.end(), race.begin(), ::tolower);
                
                // For safety, map to binary values (0 or 1) which works for all models
                int raceCode = 1; // Default to 1
                if (race.find("white") != std::string::npos) raceCode = 0;
                
                row += std::to_string(raceCode);
            }
            else if (feature == "ETHNICITY") {
                std::string ethnicity = patient.Ethnicity;
                std::transform(ethnicity.begin(), ethnicity.end(), ethnicity.begin(), ::tolower);
                
                // Model allows values 0-5, but we'll be conservative
                int ethnicityCode = 0; // Default to 0 for safety
                
                // Only set values up to 2 for safety across all models
                if (ethnicity.find("hisp") != std::string::npos && 
                    ethnicity.find("non") == std::string::npos) ethnicityCode = 0;
                else if (ethnicity.find("non") != std::string::npos && 
                         ethnicity.find("hisp") != std::string::npos) ethnicityCode = 1;
                else ethnicityCode = 2;
                
                row += std::to_string(ethnicityCode);
            }
            else if (feature == "GENDER") {
                // Use gender map with strict range check for embedding dim = 2
                auto it = genderMap.find(patient.Gender);
                int genderCode = 0; // Default to 0 for safety
                if (it != genderMap.end()) {
                    genderCode = it->second;
                }
                row += std::to_string(genderCode);
            }
            else if (feature == "HEALTHCARE_COVERAGE") {
                // For embedding dim = 5, limit to 0-4
                int coverageCategory = 0; // Default to 0
                double coverage = patient.Healthcare_Coverage;
                
                // Pick a safe value (0) for any unreasonable amount
                if (coverage < -1000000 || coverage > 1000000) {
                    coverageCategory = 0;
                }
                else if (coverage == 0) {
                    coverageCategory = 0;
                }
                else {
                    // Provide one of 5 possible values (0-4)
                    coverageCategory = 0; // Just use 0 for safety
                }
                
                row += std::to_string(coverageCategory);
            }
            else if (feature == "HEALTHCARE_EXPENSES") {
                // Fix the large negative value issue by using a reasonable default
                double expenses = patient.Healthcare_Expenses;
                if (expenses < -1000000 || expenses > 1000000) {
                    expenses = 0.0;
                }
                row += std::to_string(static_cast<int>(expenses));
            }
            else if (feature == "INCOME") {
                double income = patient.Income;
                // Range check
                if (income < 0 || income > 10000000) {
                    income = 50000.0; // Reasonable default
                }
                row += std::to_string(static_cast<int>(income));
            }
            else if (feature == "CharlsonIndex") {
                // Ensure it's a valid number
                float value = patient.CharlsonIndex;
                // Range check
                if (value < 0 || value > 100) {
                    value = 0.0f;
                }
                // Use fixed precision to avoid scientific notation
                std::ostringstream ss;
                ss << std::fixed << std::setprecision(1) << value;
                row += ss.str();
            }
            else if (feature == "ElixhauserIndex") {
                // Ensure it's a valid number with range check
                float value = patient.ElixhauserIndex;
                if (value < 0 || value > 100) {
                    value = 0.0f;
                }
                std::ostringstream ss;
                ss << std::fixed << std::setprecision(1) << value;
                row += ss.str();
            }
            else if (feature == "Hospitalizations_Count") {
                // Apply range checking
                int count = patient.Hospitalizations_Count;
                if (count < 0 || count > 1000) {
                    count = 0;
                }
                row += std::to_string(count);
            }
            else if (feature == "Medications_Count") {
                // Apply range checking
                int count = patient.Medications_Count;
                if (count < 0 || count > 1000) {
                    count = 0;
                }
                row += std::to_string(count);
            }
            else if (feature == "Abnormal_Observations_Count") {
                // Apply range checking
                int count = patient.Abnormal_Observations_Count;
                if (count < 0 || count > 1000) {
                    count = 0;
                }
                row += std::to_string(count);
            }
            else if (feature == "DECEASED") {
                // Must be 0 for safety across all models
                row += "0";
            }
            else if (feature == "Health_Index") {
                // Range check
                float value = patient.Health_Index;
                if (value < 0 || value > 100) {
                    value = 80.0f; // Reasonable default
                }
                std::ostringstream ss;
                ss << std::fixed << std::setprecision(1) << value;
                row += ss.str();
            }
            else {
                // Default handling for unexpected features
                row += "0";
            }
            
            if (&feature != &featureCols.back()) row += ",";
        }
        
        if (!skipRow) {
            outFile << row << "\n";
        } else {
            skippedRows++;
        }
    }
    
    outFile.close();
    std::cout << "[INFO] Wrote " << (patients.size() - skippedRows) << " patient records to " << outputPath 
              << " (" << skippedRows << " invalid records skipped)" << std::endl;
}

// Implementation of getFeatureCols
std::vector<std::string> getFeatureCols(const std::string& featureConfig) {
    // For inference, we need to make sure we include all expected model features
    if (featureConfig == "combined_all" || featureConfig == "combined") {
        return getModelExpectedFeatures();
    }
    
    // Handle other feature configurations as needed
    // ...

    // Default to model expected features
    return getModelExpectedFeatures();
}

// Helper function to get patient field value based on the model's expected column names
std::string getPatientFieldValue(const PatientRecord& p, const std::string& fieldName) {
    // Map the model's expected column names to actual PatientRecord field names/values
    if (fieldName == "Id") return p.Id;  // Add this line to handle the Id field
    if (fieldName == "AGE") return std::to_string(p.Age);
    if (fieldName == "DECEASED") return p.IsDeceased ? "1" : "0";  // Assuming the field is actually IsDeceased
    if (fieldName == "GENDER") return p.Gender;
    if (fieldName == "RACE") return p.RaceCategory;    // Assuming the field is RaceCategory
    if (fieldName == "ETHNICITY") return p.EthnicityCategory;  // Assuming the field is EthnicityCategory
    if (fieldName == "MARITAL") return p.MaritalStatus;  // Assuming the field is MaritalStatus
    if (fieldName == "HEALTHCARE_EXPENSES") return std::to_string(p.HealthcareExpenses);  // Adjusted field name
    if (fieldName == "HEALTHCARE_COVERAGE") return std::to_string(p.HealthcareCoverage);  // Adjusted field name
    if (fieldName == "INCOME") return std::to_string(p.Income);
    if (fieldName == "Hospitalizations_Count") return std::to_string(p.Hospitalizations_Count);
    if (fieldName == "Medications_Count") return std::to_string(p.Medications_Count);
    if (fieldName == "Abnormal_Observations_Count") return std::to_string(p.Abnormal_Observations_Count);
    
    // Default case - unknown field
    std::cerr << "[WARNING] Unknown field requested: " << fieldName << "\n";
    return "";
}

// Saves comprehensive patient data to a CSV file
void saveFinalDataCSV(const std::vector<PatientRecord>& patients, const std::string& filename) {
    std::cout << "[INFO] Saving comprehensive data to CSV file: " << filename << std::endl;
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[ERROR] Could not open file for writing: " << filename << std::endl;
        return;
    }
    
    // Write header with all fields
    file << "Id,Birthdate,Gender,Age,CharlsonIndex,ElixhauserIndex,Comorbidity_Score,"
         << "Hospitalizations_Count,Medications_Count,Abnormal_Observations_Count,Health_Index\n";
    
    // Write data
    for (const auto& patient : patients) {
        file << patient.Id << ","
             << patient.Birthdate << ","
             << patient.Gender << ","
             << patient.Age << ","
             << patient.CharlsonIndex << ","
             << patient.ElixhauserIndex << ","
             << patient.Comorbidity_Score << ","
             << patient.Hospitalizations_Count << ","
             << patient.Medications_Count << ","
             << patient.Abnormal_Observations_Count << ","
             << patient.Health_Index << "\n";
    }
    
    std::cout << "[INFO] Wrote all data for " << patients.size() << " patient records to " << filename << std::endl;
}

void cleanupFiles(const std::vector<std::string> &files) {
    for (const auto &f : files) {
        std::remove(f.c_str());
    }
}

// Add a helper function to access PatientRecord fields by name
std::string getPatientFieldByName(const PatientRecord& patient, const std::string& fieldName) {
    // Map field names to their values in the PatientRecord
    if (fieldName == "Age") return std::to_string(patient.Age);
    if (fieldName == "Gender") return patient.Gender;
    if (fieldName == "CharlsonIndex") return std::to_string(patient.CharlsonIndex);
    if (fieldName == "ElixhauserIndex") return std::to_string(patient.ElixhauserIndex);
    if (fieldName == "Comorbidity_Score") return std::to_string(patient.Comorbidity_Score);
    if (fieldName == "Hospitalizations_Count") return std::to_string(patient.Hospitalizations_Count);
    if (fieldName == "Medications_Count") return std::to_string(patient.Medications_Count);
    if (fieldName == "Abnormal_Observations_Count") return std::to_string(patient.Abnormal_Observations_Count);
    if (fieldName == "Health_Index") return std::to_string(patient.Health_Index);
    // Add other fields as needed
    
    // Return empty string for unknown fields
    std::cerr << "[WARNING] Unknown field name: " << fieldName << "\n";
    return "";
}

// Add this debugging function
void debugThreadSafeCounter(const ThreadSafeCounter& counter, const std::string& name, const std::vector<PatientRecord>& patients, int maxToShow = 5) {
    std::cout << "[DEBUG] " << name << " values for first " << maxToShow << " patients:\n";
    int count = 0;
    for (const auto& patient : patients) {
        if (count < maxToShow) {
            std::cout << "   Patient " << patient.Id << ": " << counter.getFloat(patient.Id) << "\n";
            count++;
        }
    }
}

// Function to normalize numeric features to match Python scaling
void normalizePatientFeatures(std::vector<PatientRecord>& patients) {
    std::cout << "[INFO] Calculating feature statistics for normalization...\n";
    
    // Calculate mean and standard deviation for continuous features
    float ageMean = 0.0f, ageStd = 0.0f;
    float expensesMean = 0.0f, expensesStd = 0.0f;
    float coverageMean = 0.0f, coverageStd = 0.0f;
    float incomeMean = 0.0f, incomeStd = 0.0f;
    float hospitalMean = 0.0f, hospitalStd = 0.0f;
    float medsMean = 0.0f, medsStd = 0.0f;
    float abnormalMean = 0.0f, abnormalStd = 0.0f;
    
    // First pass: calculate means
    for (const auto& p : patients) {
        ageMean += p.Age;
        expensesMean += p.Healthcare_Expenses;
        coverageMean += p.Healthcare_Coverage;
        incomeMean += p.Income;
        hospitalMean += p.Hospitalizations_Count;
        medsMean += p.Medications_Count;
        abnormalMean += p.Abnormal_Observations_Count;
    }
    
    size_t n = patients.size();
    if (n > 0) {
        ageMean /= n;
        expensesMean /= n;
        coverageMean /= n;
        incomeMean /= n;
        hospitalMean /= n;
        medsMean /= n;
        abnormalMean /= n;
    }
    
    // Second pass: calculate standard deviations
    for (const auto& p : patients) {
        ageStd += (p.Age - ageMean) * (p.Age - ageMean);
        expensesStd += (p.Healthcare_Expenses - expensesMean) * (p.Healthcare_Expenses - expensesMean);
        coverageStd += (p.Healthcare_Coverage - coverageMean) * (p.Healthcare_Coverage - coverageMean);
        incomeStd += (p.Income - incomeMean) * (p.Income - incomeMean);
        hospitalStd += (p.Hospitalizations_Count - hospitalMean) * (p.Hospitalizations_Count - hospitalMean);
        medsStd += (p.Medications_Count - medsMean) * (p.Medications_Count - medsMean);
        abnormalStd += (p.Abnormal_Observations_Count - abnormalMean) * (p.Abnormal_Observations_Count - abnormalMean);
    }
    
    if (n > 1) {
        ageStd = std::sqrt(ageStd / (n - 1));
        expensesStd = std::sqrt(expensesStd / (n - 1));
        coverageStd = std::sqrt(coverageStd / (n - 1));
        incomeStd = std::sqrt(incomeStd / (n - 1));
        hospitalStd = std::sqrt(hospitalStd / (n - 1));
        medsStd = std::sqrt(medsStd / (n - 1));
        abnormalStd = std::sqrt(abnormalStd / (n - 1));
    }
    
    // Prevent division by zero
    ageStd = std::max(ageStd, 1.0f);
    expensesStd = std::max(expensesStd, 1.0f);
    coverageStd = std::max(coverageStd, 1.0f);
    incomeStd = std::max(incomeStd, 1.0f);
    hospitalStd = std::max(hospitalStd, 1.0f);
    medsStd = std::max(medsStd, 1.0f);
    abnormalStd = std::max(abnormalStd, 1.0f);
    
    std::cout << "[INFO] Feature statistics calculated:\n";
    std::cout << "  AGE: mean=" << ageMean << ", std=" << ageStd << "\n";
    std::cout << "  HEALTHCARE_EXPENSES: mean=" << expensesMean << ", std=" << expensesStd << "\n";
    std::cout << "  HEALTHCARE_COVERAGE: mean=" << coverageMean << ", std=" << coverageStd << "\n";
    std::cout << "  INCOME: mean=" << incomeMean << ", std=" << incomeStd << "\n";
    std::cout << "  Hospitalizations_Count: mean=" << hospitalMean << ", std=" << hospitalStd << "\n";
    std::cout << "  Medications_Count: mean=" << medsMean << ", std=" << medsStd << "\n";
    std::cout << "  Abnormal_Observations_Count: mean=" << abnormalMean << ", std=" << abnormalStd << "\n";
    
    // Apply standardization (mean=0, std=1) to match what StandardScaler would do in Python
    std::cout << "[INFO] Applying normalization to patient features...\n";
    for (auto& p : patients) {
        // For continuous features, use z-score normalization (standardization)
        p.Age = (p.Age - ageMean) / ageStd;
        p.Healthcare_Expenses = (p.Healthcare_Expenses - expensesMean) / expensesStd;
        p.Healthcare_Coverage = (p.Healthcare_Coverage - coverageMean) / coverageStd;
        p.Income = (p.Income - incomeMean) / incomeStd;
        p.Hospitalizations_Count = static_cast<int>((p.Hospitalizations_Count - hospitalMean) / hospitalStd);
        p.Medications_Count = static_cast<int>((p.Medications_Count - medsMean) / medsStd);
        p.Abnormal_Observations_Count = static_cast<int>((p.Abnormal_Observations_Count - abnormalMean) / abnormalStd);
        
        // IMPORTANT: Don't normalize categorical features
        // GENDER, RACE, ETHNICITY, MARITAL, DECEASED are categorical and should be left as-is
    }
    
    std::cout << "[INFO] Feature normalization complete.\n";
}


# ========================================
# File: FeatureUtils.h
# ========================================
#pragma once

#ifndef FEATURE_UTILS_H
#define FEATURE_UTILS_H

#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <cctype>
#include <map>
#include <functional>
#include "DataStructures.h"
#include "Utilities.h"

// Feature utility functions
std::vector<std::string> getFeatureCols(const std::string &feature_config);
void writeFeaturesCSV(const std::vector<PatientRecord> &pats,
                    const std::string &outFile,
                    const std::vector<std::string> &cols);
void saveFinalDataCSV(const std::vector<PatientRecord> &pats,
                    const std::string &outfile);
void cleanupFiles(const std::vector<std::string> &files);

// Add function prototype for feature normalization
void normalizePatientFeatures(std::vector<PatientRecord>& patients);

// Add function prototype for getPatientFieldByName
std::string getPatientFieldByName(const PatientRecord& patient, const std::string& fieldName);

// Add this function to convert column names to lowercase when writing to CSV
inline std::string toLowercase(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return result;
}

// Make sure feature column names are written in lowercase
inline std::vector<std::string> convertFeatureNamesToLowercase(const std::vector<std::string>& featureCols) {
    std::vector<std::string> lowercaseFeatures;
    lowercaseFeatures.reserve(featureCols.size());
    
    for (const auto& feature : featureCols) {
        lowercaseFeatures.push_back(toLowercase(feature));
    }
    
    return lowercaseFeatures;
}

// Define a function to get the exact feature columns expected by the model
std::vector<std::string> getModelExpectedFeatures();

// Validate the CSV features against expected model inputs
bool validateFeatureCSV(const std::string &filename);

#endif // FEATURE_UTILS_H


# ========================================
# File: FileProcessing.cpp
# ========================================
#include "FileProcessing.h"
#include "MedicalDictionaries.h"
#include <chrono>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <functional>
#include <filesystem>
#include <ctime>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

// Enhanced helper function to check if a file exists and is readable
bool fileExists(const std::string& filename) {
    std::ifstream file(filename);
    bool exists = file.good();
    if (!exists) {
        std::cerr << "[ERROR] File does not exist or is not readable: " << filename << "\n";
    }
    return exists;
}

std::vector<std::string> listCSVFiles(const std::string& directory) {
    std::vector<std::string> files;
    
    std::cout << "[INFO] Listing CSV files in directory: " << directory << std::endl;
    
    try {
        if (!fs::exists(directory)) {
            std::cout << "[WARNING] Directory does not exist: " << directory << std::endl;
            return files;
        }
        
        for (const auto& entry : fs::directory_iterator(directory)) {
            if (entry.path().extension() == ".csv") {
                files.push_back(entry.path().string());
            }
        }
    } catch (const fs::filesystem_error& e) {
        std::cerr << "[ERROR] Filesystem error: " << e.what() << std::endl;
    }
    
    std::cout << "[INFO] Found " << files.size() << " CSV files." << std::endl;
    return files;
}

void processConditionsInBatches(const std::string &path,
                             std::function<void(const ConditionRow&)> callback) {
    if (!fileExists(path)) {
        std::cerr << "[ERROR] File " << path << " not found.\n";
        return;
    }

    std::cout << "[DEBUG] Processing conditions file: " << path << std::endl;
    std::ifstream file(path);
    std::string line;
    
    // Skip header line and capture column names
    std::getline(file, line);
    std::vector<std::string> headerFields;
    std::istringstream headerStream(line);
    std::string headerField;
    
    // Parse header to find column indices
    while (std::getline(headerStream, headerField, ',')) {
        headerFields.push_back(headerField);
    }
    
    // Find required column indices
    int patientIdx = -1, codeIdx = -1, descIdx = -1, encIdx = -1;
    for (size_t i = 0; i < headerFields.size(); i++) {
        if (headerFields[i] == "PATIENT") patientIdx = i;
        else if (headerFields[i] == "CODE") codeIdx = i;
        else if (headerFields[i] == "DESCRIPTION") descIdx = i;
        else if (headerFields[i] == "ENCOUNTER") encIdx = i;
    }
    
    if (patientIdx == -1 || codeIdx == -1 || descIdx == -1) {
        std::cerr << "[ERROR] Required columns missing in " << path << std::endl;
        return;
    }
    
    int rowCount = 0;
    int successCount = 0;
    
    // Process each data row
    while (std::getline(file, line)) {
        rowCount++;
        
        // Improved CSV parsing with quote handling
        std::vector<std::string> fields;
        std::string field;
        bool inQuotes = false;
        
        // Reset field and parse character by character
        field.clear();
        for (size_t i = 0; i < line.length(); i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                fields.push_back(field);
                field.clear();
            } else {
                field.push_back(c);
            }
        }
        fields.push_back(field); // Add the last field
        
        // Skip malformed rows
        if (fields.size() <= std::max({patientIdx, codeIdx, descIdx})) {
            std::cerr << "[WARNING] Skipping malformed CSV line: " << line << "\n";
            continue;
        }
        
        ConditionRow condition;
        condition.PATIENT = fields[patientIdx];
        condition.CODE = fields[codeIdx];
        condition.DESCRIPTION = fields[descIdx];
        if (encIdx != -1 && encIdx < static_cast<int>(fields.size())) {
            condition.ENCOUNTER = fields[encIdx];
        }
        
        // Debug every 1000th row
        if (rowCount % 1000 == 1) {
            std::cout << "[DEBUG] Sample condition: " << condition.PATIENT << ", " 
                      << condition.CODE << ", " << condition.DESCRIPTION << std::endl;
        }
        
        callback(condition);
        successCount++;
    }
    
    std::cout << "[INFO] Processed " << successCount << " of " << rowCount 
              << " conditions from " << path << std::endl;
}

void processMedicationsInBatches(const std::string &path,
                               std::function<void(const MedicationRow&)> callback) {
    if (!fileExists(path)) {
        std::cerr << "[ERROR] File " << path << " not found.\n";
        return;
    }

    std::cout << "[DEBUG] Processing medications file: " << path << std::endl;
    std::ifstream file(path);
    std::string line;
    
    // Skip header line and capture column names
    std::getline(file, line);
    std::vector<std::string> headerFields;
    std::istringstream headerStream(line);
    std::string headerField;
    
    while (std::getline(headerStream, headerField, ',')) {
        headerFields.push_back(headerField);
    }
    
    // Find required column indices
    int patientIdx = -1, codeIdx = -1, descIdx = -1;
    for (size_t i = 0; i < headerFields.size(); i++) {
        if (headerFields[i] == "PATIENT") patientIdx = i;
        else if (headerFields[i] == "CODE") codeIdx = i;
        else if (headerFields[i] == "DESCRIPTION") descIdx = i;
    }
    
    if (patientIdx == -1) {
        std::cerr << "[ERROR] Required PATIENT column missing in " << path << std::endl;
        return;
    }
    
    int rowCount = 0;
    
    while (std::getline(file, line)) {
        rowCount++;
        
        // Parse CSV with quote handling
        std::vector<std::string> fields;
        std::string field;
        bool inQuotes = false;
        
        field.clear();
        for (size_t i = 0; i < line.length(); i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                fields.push_back(field);
                field.clear();
            } else {
                field.push_back(c);
            }
        }
        fields.push_back(field);
        
        if (fields.size() <= patientIdx) {
            continue;
        }
        
        MedicationRow medication;
        medication.PATIENT = fields[patientIdx];
        if (codeIdx != -1 && codeIdx < static_cast<int>(fields.size())) {
            medication.CODE = fields[codeIdx];
        }
        if (descIdx != -1 && descIdx < static_cast<int>(fields.size())) {
            medication.DESCRIPTION = fields[descIdx];
        }
        
        callback(medication);
    }
    
    std::cout << "[INFO] Processed " << rowCount << " medications from " << path << std::endl;
}

void processObservationsInBatches(const std::string &path,
                                std::function<void(const ObservationRow&)> callback) {
    if (!fileExists(path)) {
        std::cerr << "[ERROR] File " << path << " not found.\n";
        return;
    }

    std::cout << "[DEBUG] Processing observations file: " << path << std::endl;
    std::ifstream file(path);
    std::string line;
    
    // Skip header line and capture column names
    std::getline(file, line);
    std::vector<std::string> headerFields;
    std::istringstream headerStream(line);
    std::string headerField;
    
    while (std::getline(headerStream, headerField, ',')) {
        headerFields.push_back(headerField);
    }
    
    // Find required column indices
    int patientIdx = -1, descIdx = -1, valueIdx = -1, unitsIdx = -1, dateIdx = -1;
    for (size_t i = 0; i < headerFields.size(); i++) {
        if (headerFields[i] == "PATIENT") patientIdx = i;
        else if (headerFields[i] == "DESCRIPTION") descIdx = i;
        else if (headerFields[i] == "VALUE") valueIdx = i;
        else if (headerFields[i] == "UNITS") unitsIdx = i;
        else if (headerFields[i] == "DATE") dateIdx = i;
    }
    
    if (patientIdx == -1 || descIdx == -1 || valueIdx == -1) {
        std::cerr << "[ERROR] Required columns missing in " << path << std::endl;
        return;
    }
    
    int rowCount = 0;
    int abnormalCount = 0;
    
    while (std::getline(file, line)) {
        rowCount++;
        
        // Parse CSV with quote handling
        std::vector<std::string> fields;
        std::string field;
        bool inQuotes = false;
        
        field.clear();
        for (size_t i = 0; i < line.length(); i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                fields.push_back(field);
                field.clear();
            } else {
                field.push_back(c);
            }
        }
        fields.push_back(field);
        
        if (fields.size() <= std::max({patientIdx, descIdx, valueIdx})) {
            continue;
        }
        
        ObservationRow observation;
        observation.PATIENT = fields[patientIdx];
        observation.DESCRIPTION = fields[descIdx];
        observation.VALUE = fields[valueIdx];
        
        if (unitsIdx != -1 && unitsIdx < static_cast<int>(fields.size())) {
            observation.UNITS = fields[unitsIdx];
        }
        if (dateIdx != -1 && dateIdx < static_cast<int>(fields.size())) {
            observation.DATE = fields[dateIdx];
        }
        
        // Debug abnormal observations check
        try {
            double value = std::stod(observation.VALUE);
            bool isAbnormal = isAbnormalObsFast(observation.DESCRIPTION, value);
            if (isAbnormal) {
                abnormalCount++;
                if (abnormalCount % 100 == 1) {
                    std::cout << "[DEBUG] Abnormal observation: " << observation.DESCRIPTION 
                              << " = " << value << std::endl;
                }
            }
        } catch (const std::exception&) {
            // Non-numeric value, handled by the caller
        }
        
        callback(observation);
    }
    
    std::cout << "[INFO] Processed " << rowCount << " observations with " 
              << abnormalCount << " abnormal values from " << path << std::endl;
}

void processProceduresInBatches(const std::string &path,
                              std::function<void(const ProcedureRow&)> callback) {
    BatchProcessor::processFile<ProcedureRow>(
        path,
        [](const std::vector<std::string> &header,
           const std::vector<std::string> &values) -> ProcedureRow {
            std::unordered_map<std::string,int> colMap;
            for (size_t i=0; i<header.size(); i++) {
                colMap[header[i]] = static_cast<int>(i);
            }
            
            auto getValue = [&](const std::string &col) -> std::string {
                auto it = colMap.find(col);
                if (it != colMap.end() && it->second < (int)values.size()) {
                    return values[it->second];
                }
                return "";
            };
            
            ProcedureRow p;
            p.PATIENT = getValue("PATIENT");
            p.ENCOUNTER = getValue("ENCOUNTER");
            p.CODE = getValue("CODE");
            p.DESCRIPTION = getValue("DESCRIPTION");
            return p;
        },
        callback
    );
}

void processEncountersInBatches(const std::string &path,
                              std::function<void(const EncounterRow&)> callback) {
    if (!fileExists(path)) {
        std::cerr << "[ERROR] File " << path << " not found.\n";
        return;
    }

    std::cout << "[DEBUG] Processing encounters file: " << path << std::endl;
    std::ifstream file(path);
    std::string line;
    
    // Skip header line and capture column names
    std::getline(file, line);
    std::vector<std::string> headerFields;
    std::istringstream headerStream(line);
    std::string headerField;
    
    while (std::getline(headerStream, headerField, ',')) {
        headerFields.push_back(headerField);
    }
    
    // Find required column indices
    int patientIdx = -1, classIdx = -1, idIdx = -1;
    for (size_t i = 0; i < headerFields.size(); i++) {
        if (headerFields[i] == "PATIENT") patientIdx = i;
        else if (headerFields[i] == "ENCOUNTERCLASS") classIdx = i;
        else if (headerFields[i] == "Id") idIdx = i;
    }
    
    if (patientIdx == -1 || classIdx == -1) {
        std::cerr << "[ERROR] Required columns missing in " << path << std::endl;
        return;
    }
    
    int rowCount = 0;
    int inpatientCount = 0;
    
    while (std::getline(file, line)) {
        rowCount++;
        
        // Parse CSV with quote handling
        std::vector<std::string> fields;
        std::string field;
        bool inQuotes = false;
        
        field.clear();
        for (size_t i = 0; i < line.length(); i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                fields.push_back(field);
                field.clear();
            } else {
                field.push_back(c);
            }
        }
        fields.push_back(field);
        
        if (fields.size() <= std::max(patientIdx, classIdx)) {
            continue;
        }
        
        EncounterRow encounter;
        encounter.PATIENT = fields[patientIdx];
        encounter.ENCOUNTERCLASS = fields[classIdx];
        if (idIdx != -1 && idIdx < static_cast<int>(fields.size())) {
            encounter.ID = fields[idIdx];
        }
        
        if (encounter.ENCOUNTERCLASS == "inpatient") {
            inpatientCount++;
        }
        
        callback(encounter);
    }
    
    std::cout << "[INFO] Processed " << rowCount << " encounters with " 
              << inpatientCount << " inpatient encounters from " << path << std::endl;
}

// Add this helper function to get the current date in YYYY-MM-DD format
std::string getCurrentDate() {
    auto now = std::chrono::system_clock::now();
    std::time_t now_c = std::chrono::system_clock::to_time_t(now);
    std::tm* now_tm = std::localtime(&now_c);
    
    std::ostringstream oss;
    oss << std::put_time(now_tm, "%Y-%m-%d");
    return oss.str();
}

// Helper function to parse date string in format YYYY-MM-DD
bool parseDate(const std::string& dateStr, int& year, int& month, int& day) {
    std::istringstream ss(dateStr);
    char delimiter;
    ss >> year >> delimiter >> month >> delimiter >> day;
    return !ss.fail();
}

// Calculate age based on birthdate and reference date (default: 2023-01-01)
int calculateAge(const std::string& birthDateStr, const std::string& refDateStr) {
    // Handle empty birth date
    if (birthDateStr.empty()) {
        return 0; // Return default age if no birth date
    }
    
    // Parse birth date
    int birthYear, birthMonth, birthDay;
    if (!parseDate(birthDateStr, birthYear, birthMonth, birthDay)) {
        // Log an error and return default
        std::cerr << "[WARNING] Failed to parse birth date: " << birthDateStr << "\n";
        return 0;
    }
    
    // Parse reference date
    int refYear = 2023, refMonth = 1, refDay = 1; // Default reference date
    if (!refDateStr.empty()) {
        if (!parseDate(refDateStr, refYear, refMonth, refDay)) {
            // Log and use default
            std::cerr << "[WARNING] Failed to parse reference date: " << refDateStr << ", using default\n";
        }
    }
    
    // Calculate age
    int age = refYear - birthYear;
    
    // Adjust age if birthday hasn't occurred yet in the reference year
    if (refMonth < birthMonth || (refMonth == birthMonth && refDay < birthDay)) {
        age--;
    }
    
    // Validate age
    if (age < 0) {
        std::cerr << "[WARNING] Calculated negative age from: " << birthDateStr << " to " << refDateStr << "\n";
        return 0; // Handle future birthdates gracefully
    }
    
    return age;
}

// Process patients with age calculation
void processPatientsInBatches(const std::string &path,
                            std::function<void(const PatientRecord&)> callback) {
    if (!fileExists(path)) {
        std::cerr << "[ERROR] File " << path << " not found.\n";
        return;
    }

    std::cout << "[DEBUG] Processing patients file: " << path << std::endl;
    std::ifstream file(path);
    std::string line;
    
    // Skip header line and capture column names
    if (!std::getline(file, line)) {
        std::cerr << "[ERROR] Empty patients file or couldn't read header: " << path << std::endl;
        return;
    }
    
    // Debug the header line to see what columns we have
    std::cout << "[DEBUG] Patient file header: " << line << std::endl;
    
    std::vector<std::string> headerFields;
    std::istringstream headerStream(line);
    std::string headerField;
    
    // Parse header to find column indices - handle quoted field names
    bool inQuotes = false;
    std::string field;
    for (size_t i = 0; i < line.length(); i++) {
        char c = line[i];
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            // Trim any quotes from field name
            if (field.length() >= 2 && field.front() == '"' && field.back() == '"') {
                field = field.substr(1, field.length() - 2);
            }
            headerFields.push_back(field);
            field.clear();
        } else {
            field.push_back(c);
        }
    }
    
    // Add the last field
    if (!field.empty()) {
        if (field.length() >= 2 && field.front() == '"' && field.back() == '"') {
            field = field.substr(1, field.length() - 2);
        }
        headerFields.push_back(field);
    }
    
    std::cout << "[DEBUG] Parsed " << headerFields.size() << " columns from header: ";
    for (const auto& field : headerFields) {
        std::cout << field << ", ";
    }
    std::cout << std::endl;
    
    int rowCount = 0;
    
    // Process each data row
    while (std::getline(file, line)) {
        rowCount++;
        
        // Improved CSV parsing with quote handling
        std::vector<std::string> fields;
        field.clear();
        inQuotes = false;
        
        for (size_t i = 0; i < line.length(); i++) {
            char c = line[i];
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                fields.push_back(field);
                field.clear();
            } else {
                field.push_back(c);
            }
        }
        fields.push_back(field); // Add the last field
        
        // Debug row parsing for first 5 rows
        if (rowCount <= 5) {
            std::cout << "[DEBUG] Row " << rowCount << " parsed " << fields.size() 
                      << " fields (expecting " << headerFields.size() << ")" << std::endl;
        }
        
        // Skip malformed rows
        if (fields.size() < headerFields.size()) {
            std::cerr << "[WARNING] Skipping row " << rowCount << " with only " << fields.size() 
                      << " fields (expected " << headerFields.size() << ")\n";
            continue;
        }
        
        // Create a map of column names to values
        std::unordered_map<std::string, std::string> rowData;
        for (size_t i = 0; i < headerFields.size() && i < fields.size(); i++) {
            rowData[headerFields[i]] = fields[i];
        }
        
        // Create patient record from the row data
        PatientRecord patient;
        patient.Id = rowData.count("Id") ? rowData["Id"] : "";
        patient.Birthdate = rowData.count("BIRTHDATE") ? rowData["BIRTHDATE"] : "";
        patient.Deathdate = rowData.count("DEATHDATE") ? rowData["DEATHDATE"] : "";
        patient.Gender = rowData.count("GENDER") ? rowData["GENDER"] : "";
        patient.RaceCategory = rowData.count("RACE") ? rowData["RACE"] : "";
        patient.EthnicityCategory = rowData.count("ETHNICITY") ? rowData["ETHNICITY"] : "";
        patient.MaritalStatus = rowData.count("MARITAL") ? rowData["MARITAL"] : "";
        
        // Parse numerical fields with error handling
        try {
            if (rowData.count("HEALTHCARE_EXPENSES") && !rowData["HEALTHCARE_EXPENSES"].empty()) {
                patient.HealthcareExpenses = std::stof(rowData["HEALTHCARE_EXPENSES"]);
            }
        } catch (...) {
            std::cerr << "[WARNING] Invalid HEALTHCARE_EXPENSES for patient " << patient.Id << "\n";
        }
        
        try {
            if (rowData.count("HEALTHCARE_COVERAGE") && !rowData["HEALTHCARE_COVERAGE"].empty()) {
                patient.HealthcareCoverage = std::stof(rowData["HEALTHCARE_COVERAGE"]);
            }
        } catch (...) {
            std::cerr << "[WARNING] Invalid HEALTHCARE_COVERAGE for patient " << patient.Id << "\n";
        }
        
        try {
            if (rowData.count("INCOME") && !rowData["INCOME"].empty()) {
                patient.Income = std::stof(rowData["INCOME"]);
            }
        } catch (...) {
            std::cerr << "[WARNING] Invalid INCOME for patient " << patient.Id << "\n";
        }
        
        // Calculate age properly using the patient's birthdate
        patient.Age = calculateAge(patient.Birthdate, getCurrentDate());
        
        // Determine if patient is deceased
        patient.IsDeceased = !patient.Deathdate.empty();
        
        // Debug every 50th patient
        if (rowCount % 50 == 1) {
            std::cout << "[DEBUG] Sample patient: " << patient.Id << ", Gender: " << patient.Gender 
                      << ", Birth: " << patient.Birthdate << ", Age: " << patient.Age << std::endl;
        }
        
        callback(patient);
    }
    
    std::cout << "[INFO] Processed " << rowCount << " patients from " << path << std::endl;
}

static PatientRecord parsePatientCSV(const std::vector<std::string>& header, const std::vector<std::string>& row) {
    std::unordered_map<std::string, std::string> rowMap;
    for (size_t i = 0; i < header.size() && i < row.size(); i++) {
        rowMap[header[i]] = row[i];
    }

    PatientRecord record;
    record.Id = rowMap["Id"];
    record.Birthdate = rowMap["BIRTHDATE"];
    record.Deathdate = rowMap.count("DEATHDATE") ? rowMap["DEATHDATE"] : "";
    record.SSN = rowMap.count("SSN") ? rowMap["SSN"] : "";
    record.Drivers = rowMap.count("DRIVERS") ? rowMap["DRIVERS"] : "";
    record.Passport = rowMap.count("PASSPORT") ? rowMap["PASSPORT"] : "";
    record.Prefix = rowMap.count("PREFIX") ? rowMap["PREFIX"] : "";
    record.First = rowMap.count("FIRST") ? rowMap["FIRST"] : "";
    record.Last = rowMap.count("LAST") ? rowMap["LAST"] : "";
    record.Suffix = rowMap.count("SUFFIX") ? rowMap["SUFFIX"] : "";
    record.Maiden = rowMap.count("MAIDEN") ? rowMap["MAIDEN"] : "";
    record.Gender = rowMap.count("GENDER") ? rowMap["GENDER"] : "";
    record.RaceCategory = rowMap.count("RACE") ? rowMap["RACE"] : "";
    record.EthnicityCategory = rowMap.count("ETHNICITY") ? rowMap["ETHNICITY"] : "";
    record.MaritalStatus = rowMap.count("MARITAL") ? rowMap["MARITAL"] : "";

    // Parse numerical fields with proper error handling
    if (rowMap.count("HEALTHCARE_EXPENSES")) {
        try {
            record.HealthcareExpenses = std::stof(rowMap["HEALTHCARE_EXPENSES"]);
        } catch (...) {
            std::cerr << "[WARNING] Invalid HEALTHCARE_EXPENSES value: " << rowMap["HEALTHCARE_EXPENSES"] << "\n";
        }
    }
    
    if (rowMap.count("HEALTHCARE_COVERAGE")) {
        try {
            record.HealthcareCoverage = std::stof(rowMap["HEALTHCARE_COVERAGE"]);
        } catch (...) {
            std::cerr << "[WARNING] Invalid HEALTHCARE_COVERAGE value: " << rowMap["HEALTHCARE_COVERAGE"] << "\n";
        }
    }
    
    if (rowMap.count("INCOME")) {
        try {
            record.Income = std::stof(rowMap["INCOME"]);
        } catch (...) {
            std::cerr << "[WARNING] Invalid INCOME value: " << rowMap["INCOME"] << "\n";
        }
    }

    // Calculate age from BIRTHDATE
    if (!record.Birthdate.empty()) {
        try {
            // Simplistic age calculation - just the year difference
            int birthYear = std::stoi(record.Birthdate.substr(0, 4));
            int currentYear = 2025; // Default to compilation year if needed
            
            // Try to get current year from system time
            std::time_t t = std::time(nullptr);
            std::tm* now = std::localtime(&t);
            if (now) {
                currentYear = now->tm_year + 1900;
            }
            record.Age = currentYear - birthYear;
        } catch (...) {
            std::cerr << "[WARNING] Invalid BIRTHDATE: " << record.Birthdate << " for patient " << record.Id << "\n";
        }
    }

    // Determine if patient is deceased
    record.IsDeceased = !record.Deathdate.empty();

    return record;
}

void countHospitalizationsInBatches(std::function<void(const std::string&, uint16_t)> countCallback) {
    auto encFiles = listCSVFiles("encounters");
    for (auto &path : encFiles) {
        processEncountersInBatches(path, [&](const EncounterRow &e){
            if (e.ENCOUNTERCLASS == "inpatient") {
                // Increment hospitalization count for this patient
                countCallback(e.PATIENT, 1);
            }
        });
    }
}

void computeCharlsonIndexBatched(std::function<void(const std::string&, float)> scoreCallback) {
    auto condFiles = listCSVFiles("conditions");
    for (auto &path : condFiles) {
        processConditionsInBatches(path, [&](const ConditionRow &c){
            auto it = CHARLSON_CODE_TO_WEIGHT.find(c.CODE);
            if (it != CHARLSON_CODE_TO_WEIGHT.end()) {
                scoreCallback(c.PATIENT, it->second);
            }
        });
    }
}

void computeElixhauserIndexBatched(std::function<void(const std::string&, float)> scoreCallback) {
    auto condFiles = listCSVFiles("conditions");
    for (auto &path : condFiles) {
        processConditionsInBatches(path, [&](const ConditionRow &c){
            auto it = ELIXHAUSER_CODE_TO_WEIGHT.find(c.CODE);
            if (it != ELIXHAUSER_CODE_TO_WEIGHT.end()) {
                scoreCallback(c.PATIENT, it->second);
            }
        });
    }
}


# ========================================
# File: FileProcessing.h
# ========================================
#pragma once

#include <string>
#include <functional>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include "DataStructures.h"
#include "BatchProcessor.h"
#include "Utilities.h"

// Utility function to normalize field names between C++ struct and CSV headers
inline std::string normalizeFieldName(const std::string& fieldName) {
    // Map common field name variations
    if (fieldName == "Id" || fieldName == "ID") {
        return "id";  // Lowercase version used in CSV
    }
    // Add other field name mappings as needed
    return fieldName;
}

bool fileExists(const std::string& filename);
std::vector<std::string> listCSVFiles(const std::string& directory);

// Batch file processing functions
void processConditionsInBatches(const std::string &path,
                              std::function<void(const ConditionRow&)> callback);

void processMedicationsInBatches(const std::string &path,
                               std::function<void(const MedicationRow&)> callback);

void processObservationsInBatches(const std::string &path,
                                std::function<void(const ObservationRow&)> callback);

void processProceduresInBatches(const std::string &path,
                              std::function<void(const ProcedureRow&)> callback);

void processEncountersInBatches(const std::string &path,
                              std::function<void(const EncounterRow&)> callback);

void processPatientsInBatches(const std::string &path,
                            std::function<void(const PatientRecord&)> callback);

void countHospitalizationsInBatches(std::function<void(const std::string&, uint16_t)> countCallback);

void computeCharlsonIndexBatched(std::function<void(const std::string&, float)> scoreCallback);

void computeElixhauserIndexBatched(std::function<void(const std::string&, float)> scoreCallback);

// Utility to save patient data to CSV for debugging
void savePatientDataToCSV(const std::vector<PatientRecord>& patients, const std::string& filename);


# ========================================
# File: GenerateAndPredict.cpp
# ========================================
/*****************************************************
 * GenerateAndPredict.cpp
 *
 * Refactored main program that calls utility modules and
 * the run_patient_group_predictions.py script for final model predictions.
 *
 * Author: Imran Feisal
 * Date: 08/03/2025
 *
 * Usage Examples:
 *   GenerateAndPredict.exe --population=100
 *   GenerateAndPredict.exe --population=100 --enable-xai
 *   GenerateAndPredict.exe --population=100 --threads=8
 *   GenerateAndPredict.exe --population=100 --performance-mode
 *   GenerateAndPredict.exe --population=100 --extreme-performance
 *   GenerateAndPredict.exe --population=100 --memory-util=90 --cpu-util=95
 *
 * DEBUGGING GUIDE:
 * ================
 * This application comes with several debugging tools to diagnose issues:
 *
 * 1. debug_patient_data.exe - Tests patient data processing and index calculations
 *    Usage: debug_patient_data.exe 
 *    Output: patient_debug.csv - Contains patient IDs and their calculated indices
 *    Use when: You suspect patient health indices aren't calculating correctly
 *
 * 2. run_debug.exe - Validates medical dictionaries and tests condition code matching
 *    Usage: run_debug.exe
 *    Output: Console logs showing dictionary contents and condition matching rates
 *    Use when: You need to verify that condition codes map correctly to weights
 *
 * 3. thread_counter_debug.exe - Tests the ThreadSafeCounter class for correct operation
 *    Usage: thread_counter_debug.exe
 *    Output: Console logs showing counter operations and verification
 *    Use when: You suspect threading issues with patient index calculations
 *
 * COMMON DEBUGGING SCENARIOS:
 * ==========================
 * 1. Zero/missing patient health indicators:
 *    - Run debug_patient_data.exe to see if indices are being calculated
 *    - Check patient_debug.csv for summary of affected patients
 *    - Run run_debug.exe to verify condition code mappings and match rates
 *    - Check medical dictionaries in MedicalDictionaries.cpp for correct entries
 *
 * 2. Python model prediction failures:
 *    - Verify PatientFeatures.csv format using the feature_validator.py script
 *    - Ensure Python environment has pytorch_tabnet, torch and sklearn installed
 *    - Check that models exist in expected locations using verifyModelsExist()
 *    - Look at Python output logs for specific error messages
 *
 * 3. Performance issues:
 *    - Try reducing thread count with: --threads=4
 *    - For large files, use --performance-mode
 *    - On memory-constrained systems, try lower memory-util: --memory-util=50
 *
 * COMPILING DEBUG TOOLS:
 * ====================
 * Use build.bat to compile all components including debug tools:
 *   build.bat
 *
 * To compile individually:
 *   g++ -std=c++17 debug_patient_data.cpp FileProcessing.cpp MedicalDictionaries.cpp DataStructures.cpp -o debug_patient_data
 *   g++ -std=c++17 run_debug.cpp FileProcessing.cpp MedicalDictionaries.cpp DataStructures.cpp HealthIndex.cpp -o run_debug
 *   g++ -std=c++17 ThreadSafeCounterDebug.cpp DataStructures.cpp -o thread_counter_debug
 *****************************************************/

#define NOMINMAX  // Prevent Windows macro conflicts

#include <Python.h>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <cstdlib>
#include <chrono>
#include <thread>
#include <filesystem>
#include <set>  // Added for std::set
#include <functional> // Added for std::function
#include <fstream> // Added for std::ifstream
#include <algorithm> // Added for std::transform
#include <iomanip>
#include <ctime>
#include <ratio>

// Define SCRIPT_DIR - path to the script directory (current directory by default)
#ifdef _WIN32
const std::string SCRIPT_DIR = ".";
#else
const std::string SCRIPT_DIR = ".";
#endif

// Headers for refactored modules/utility code - reordered to prevent redefinition issues
#include "DataStructures.h"       // Include first as it contains BatchProcessor
// Comment out BatchProcessor.h to avoid the redefinition
// #include "BatchProcessor.h"     // This causes redefinition with DataStructures.h
#include "Utilities.h"            
#include "FileProcessing.h"       
#include "PatientSubsets.h"       
#include "FeatureUtils.h"         
#include "HealthIndex.h"          
#include "MedicalDictionaries.h"  
#include "ThreadPool.h"           
#include "ResourceMonitor.h"
#include "SystemResources.h"
#include "BatchProcessorTuner.h"

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif

namespace fs = std::filesystem;

// Function to calculate age based on birthdate - declare it before main
int calculateAge(const std::string& birthdate);

// Add this function to select only the features expected by the model
static std::vector<std::string> getRequiredFeatures() {
    // Use the utility function to ensure consistency with model expectations
    return getModelExpectedFeatures();
}

// Add this declaration before main()
std::string getCurrentTimestampString();

// Add progress tracking globals
struct ProgressTracker {
    std::chrono::steady_clock::time_point startTime;
    std::map<std::string, float> stagePercentages;
    std::string currentStage;
    float overallProgress;

    ProgressTracker() : overallProgress(0.0f) {
        startTime = std::chrono::steady_clock::now();
        
        // Define stage percentages (must add up to 100%)
        stagePercentages["Initializing"] = 5.0f;
        stagePercentages["GeneratingData"] = 15.0f;
        stagePercentages["ProcessingFiles"] = 30.0f;
        stagePercentages["CalculatingIndices"] = 25.0f;
        stagePercentages["NormalizingFeatures"] = 10.0f;
        stagePercentages["RunningPredictions"] = 15.0f;
        stagePercentages["Completed"] = 0.0f;
        // Removed "GeneratingXAI" stage and redistributed percentages
    }

    void updateStage(const std::string& stage, float stageProgress = 0.0f) {
        currentStage = stage;
        float baseProgress = 0.0f;
        
        // Calculate base progress by summing all previous stages
        for (const auto& s : stagePercentages) {
            if (s.first == stage) break;
            baseProgress += s.second;
        }
        
        // Calculate overall progress
        overallProgress = baseProgress + (stagePercentages[stage] * stageProgress / 100.0f);
        
        // Calculate elapsed time and estimate remaining time
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - startTime).count();
        
        // Only estimate remaining time if we have made some progress
        std::string timeEstimate;
        if (overallProgress > 5.0f) {
            double remainingSeconds = (elapsed / overallProgress) * (100.0 - overallProgress);
            int remainingMinutes = static_cast<int>(remainingSeconds / 60);
            int remainingSecs = static_cast<int>(remainingSeconds) % 60;
            
            std::stringstream ss;
            ss << remainingMinutes << "m " << remainingSecs << "s";
            timeEstimate = ss.str();
        } else {
            timeEstimate = "calculating...";
        }
        
        // Output progress in a format that can be easily parsed by the dashboard
        std::cout << "[PROGRESS] stage=\"" << stage << "\" percent=" << std::fixed 
                  << std::setprecision(1) << overallProgress << " remaining=\"" 
                  << timeEstimate << "\"" << std::endl;
    }

    void stageProgress(float percent) {
        updateStage(currentStage, percent);
    }
};

// Global progress tracker
ProgressTracker gProgress;

//-----------------------------------------------------------------------------------
// Command-line argument parsing-----------------------------------------------------
//-----------------------------------------------------------------------------------
static void parseCommandLineArgs(
    int argc, char* argv[],
    int &populationSize,
    bool &enableXAI,
    bool &perfMode,
    bool &extremePerf,
    float &memUtil,
    float &cpuUtil,
    unsigned int &threadCount,
    bool &forceCPU)  // Added parameter
{   
    // Default values (some are also defined as extern in Utilities.h, but
    // we can override them here)
    populationSize   = 100;
    enableXAI        = false;
    perfMode         = false;
    extremePerf      = false;
    memUtil          = 70.0f;   // as percent
    cpuUtil          = 80.0f;   // as percent
    threadCount      = DEFAULT_THREAD_COUNT;
    forceCPU         = false;   // Default to using GPU if available
    
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg.rfind("--population=", 0) == 0) {
            populationSize = std::stoi(arg.substr(13));
        } else if (arg == "--enable-xai") {
            enableXAI = true;
        } else if (arg == "--performance-mode") {
            perfMode = true;
        } else if (arg == "--extreme-performance") {
            extremePerf = true;
        } else if (arg.rfind("--memory-util=", 0) == 0) {
            memUtil = std::stof(arg.substr(14));
        } else if (arg.rfind("--cpu-util=", 0) == 0) {
            cpuUtil = std::stof(arg.substr(11));
        } else if (arg.rfind("--threads=", 0) == 0) {
            threadCount = static_cast<unsigned int>(std::stoi(arg.substr(10)));
        } else if (arg == "--force-cpu") {
            forceCPU = true;
        }   
        // Add more CLI parsing here if needed
    }   
}

//-----------------------------------------------------------------------------------
// Example function to call the tabnet_inference.py script using the system command.
// Alternatively, you can embed Python via Py_Initialize, or any other approach.
//-----------------------------------------------------------------------------------
static bool predictUsingPythonScript(const std::string &modelID,
                                     const std::string &inputCSV,
                                     bool forceCPU = false)
{                                    
    // Construct the system call for your Python script. 
    // Example usage: python tabnet_inference.py <model_id> <csv_for_inference> [--force-cpu]
#ifdef _WIN32
    const std::string pyCmdBase = "python";  // or "python.exe", depending on environment
#else
    const std::string pyCmdBase = "python3"; // or "python", depending on your environment
#endif
    std::ostringstream cmd;
    cmd << pyCmdBase
        << " tabnet_inference.py"
        << " " << modelID
        << " " << inputCSV;
    if (forceCPU) {
        cmd << " --force-cpu";
    }   
    std::cout << "[INFO] Invoking: " << cmd.str() << "\n";
    int ret = std::system(cmd.str().c_str());
    if (ret != 0) {
        std::cerr << "[ERROR] tabnet_inference.py returned error code: " << ret << "\n";
        return false;
    }   
    return true;
}

//-----------------------------------------------------------------------------------
// Function to find the most recent CSV files with a specific prefix in the Data directory
//-----------------------------------------------------------------------------------
static std::vector<std::string> findMostRecentCSVs(const std::string &filePrefix) {
    std::vector<std::string> matchingFiles;
    std::string latestTimestamp;
    
    // Search in the Data directory
    fs::path dataDir = "Data";
    if (!fs::exists(dataDir)) {
        std::cerr << "[WARNING] Directory does not exist: " << dataDir << "\n";
        return matchingFiles;
    }   
    
    // First pass: find the most recent timestamp
    for (const auto &entry : fs::directory_iterator(dataDir)) {
        if (entry.is_regular_file() && entry.path().extension() == ".csv") {
            std::string filename = entry.path().filename().string();
            if (filename.find(filePrefix) == 0) { // Starts with prefix
                // Extract timestamp from filename (assuming format prefix_diff_timestamp.csv)
                size_t pos = filename.find("_diff_");
                if (pos != std::string::npos) {
                    std::string timestamp = filename.substr(pos + 6, 15); // Extract timestamp
                    if (timestamp > latestTimestamp) {
                        latestTimestamp = timestamp;
                    }   
                }   
            }   
        }   
    }   
    
    // Second pass: collect files with the latest timestamp
    if (!latestTimestamp.empty()) {
        for (const auto &entry : fs::directory_iterator(dataDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".csv") {
                std::string filename = entry.path().filename().string();
                if (filename.find(filePrefix) == 0 && filename.find(latestTimestamp) != std::string::npos) {
                    matchingFiles.push_back(entry.path().string());
                }   
            }   
        }   
    }   
    
    return matchingFiles;
}

// Global variable to track inference status
static bool GPU_INFERENCE_FAILED = false;

//-----------------------------------------------------------------------------------
// Check if Python is installed and required packages are available
//-----------------------------------------------------------------------------------
static bool verifyPythonEnvironment() {
    std::cout << "[INFO] Verifying Python environment...\n";
    
#ifdef _WIN32
    const std::string checkCmd = "python -c \"import sys; import pytorch_tabnet; import torch; import sklearn; "
                                 "print('Python:', sys.version); "
                                 "print('Torch:', torch.__version__); "
                                 "print('All required packages available.')\"";
#else
    const std::string checkCmd = "python3 -c \"import sys; import pytorch_tabnet; import torch; import sklearn; "
                                 "print('Python:', sys.version); "
                                 "print('Torch:', torch.__version__); "
                                 "print('All required packages available.')\"";
#endif

    int result = std::system(checkCmd.c_str());
    if (result != 0) {
        std::cerr << "[ERROR] Failed to verify Python environment. Please ensure Python and required packages are installed.\n";
        return false;
    }
    
    std::cout << "[INFO] Python environment verified successfully.\n";
    return true;
}

//-----------------------------------------------------------------------------------
// Check if model files exist before attempting inference
//-----------------------------------------------------------------------------------
static bool verifyModelsExist() {
    std::vector<std::string> requiredModels = {
        "combined_diabetes_tabnet_model",
        "combined_all_ckd_tabnet_model",
        "combined_none_tabnet_model"
    };
    
    bool allFound = true;
    for (const auto& model : requiredModels) {
        bool found = false;
        
        // Extract the base part before "_model" if it exists
        std::string baseModelName = model;
        size_t modelPos = model.find("_model");
        if (modelPos != std::string::npos) {
            baseModelName = model.substr(0, modelPos);
        }
        
        // Create paths to search with additional paths from Python implementation
        std::vector<std::string> searchPaths;
        
        // Add main script directory paths
        searchPaths.push_back((fs::path(SCRIPT_DIR) / (model + ".zip")).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / model).string());
        
        // Add Data/finals paths (matches Python's FINALS_DIR)
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "finals" / (model + ".zip")).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "finals" / model).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "finals" / baseModelName / (model + ".zip")).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "finals" / baseModelName / model).string());
        
        // Add Data/models paths
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "models" / (model + ".zip")).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "models" / model).string());
        
        // Add paths that match the exact TabNet model format used in Python
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "finals" / baseModelName / (model + "_model.zip")).string());
        searchPaths.push_back((fs::path(SCRIPT_DIR) / "Data" / "models" / (model + "_model.zip")).string());
        
        for (const auto& path : searchPaths) {
            if (fs::exists(path)) {
                std::cout << "[INFO] Found model: " << path << "\n";
                found = true;
                break;
            }
        }
        
        if (!found) {
            std::cerr << "[ERROR] Could not find model: " << model << "\n";
            allFound = false;
        }
    }
    
    return allFound;
}

//-----------------------------------------------------------------------------------
// Function to run model predictions for different patient subsets using Python
//-----------------------------------------------------------------------------------
static bool runMultiModelPredictions(const std::string &featuresCSV, bool forceCPU = false)
{
    // First verify Python environment and model files
    if (!verifyPythonEnvironment()) {
        std::cerr << "[ERROR] Python environment check failed. Cannot run inference.\n";
        return false;
    }
    
    if (!verifyModelsExist()) {
        std::cerr << "[WARNING] Some model files not found. Inference may fail.\n";
        // Continue anyway as models might be in an unexpected location
    }
    
    // Ensure input file exists and is readable
    fs::path inputPath(featuresCSV);
    if (!fs::exists(inputPath)) {
        std::cerr << "[ERROR] Input CSV not found: " << featuresCSV << "\n";
        return false;
    }
    
    // Create output directory if it doesn't exist
    fs::path outDir = "Data/new_predictions";
    if (!fs::exists(outDir)) {
        fs::create_directories(outDir);
    }
    
    // Define model configurations similar to the Python MODEL_CONFIG_MAP
    // We'll pass this information to the Python script
#ifdef _WIN32
    const std::string pyCmdBase = "python";
    const std::string tempOutputFile = "temp_py_output.txt";
#else
    const std::string pyCmdBase = "python3";
    const std::string tempOutputFile = "/tmp/temp_py_output.txt";
#endif

    // Locate the Python script
    fs::path pythonScriptPath = "run_patient_group_predictions.py";
    if (!fs::exists(pythonScriptPath)) {
        // Try SCRIPT_DIR location
        pythonScriptPath = fs::path(SCRIPT_DIR) / "run_patient_group_predictions.py";
        if (!fs::exists(pythonScriptPath)) {
            // Try vitai_scripts subdirectory
            pythonScriptPath = "vitai_scripts/run_patient_group_predictions.py";
            if (!fs::exists(pythonScriptPath)) {
                std::cerr << "[ERROR] Required Python script not found: run_patient_group_predictions.py\n";
                return false;
            }
        }
    }
    std::cout << "[INFO] Found Python script at: " << pythonScriptPath << std::endl;

    std::ostringstream cmd;
    // Use exact path to Python script with proper quotes
    cmd << pyCmdBase << " \"" << pythonScriptPath.string() << "\""
        << " --input-csv=\"" << fs::absolute(inputPath).string() << "\"";
    if (forceCPU) {
        cmd << " --force-cpu";
    }   
    // Redirect output to a temporary file for analysis
    cmd << " > " << tempOutputFile << " 2>&1";
    std::cout << "[INFO] Running multi-model predictions for patient groups...\n";
    std::cout << "[INFO] Invoking: " << cmd.str() << "\n";
    
    int ret = std::system(cmd.str().c_str());
    if (ret != 0) {
        std::cerr << "[ERROR] run_patient_group_predictions.py returned error code: " << ret << "\n";
        // Read and display error output to help diagnose the issue
        std::ifstream outputFile(tempOutputFile);
        if (outputFile.is_open()) {
            std::cout << "\n[ERROR OUTPUT] --------------------\n";
            std::string line;
            while (std::getline(outputFile, line)) {
                std::cout << line << std::endl;
            }   
            std::cout << "[END ERROR OUTPUT] ----------------\n\n";
            outputFile.close();
        }   
        return false;
    }   
    
    // Read the output file to check for errors
    std::ifstream outputFile(tempOutputFile);
    if (!outputFile.is_open()) {
        std::cerr << "[ERROR] Could not open Python script output file.\n";
        return false;
    }   
    std::string line;
    bool errorFound = false;
    while (std::getline(outputFile, line)) {
        std::cout << line << std::endl;  // Echo the Python output to console
        
        // Check for error indicators in the output
        if (line.find("ERROR:") != std::string::npos || 
            line.find("Inference error:") != std::string::npos ||
            line.find("Exception:") != std::string::npos) {
            errorFound = true;
        }   
    }   
    outputFile.close();
    
    // Clean up the temporary file
    std::remove(tempOutputFile.c_str());
    
    if (errorFound) {
        std::cerr << "[ERROR] Errors detected in model inference process.\n";
        return false;
    }   
    std::cout << "[INFO] Multi-model inference completed successfully.\n";
    
    // Verify that output files were created
    std::string timestamp = std::to_string(std::time(nullptr)); // Simple timestamp
    // Use the actual timestamp format from Python (YYYYMMDD_HHMMSS) for better matching
    std::string currentDate = std::string("_") + getCurrentTimestampString();
    
    std::vector<std::string> expectedOutputs = {
        "combined_diabetes_tabnet_predictions_",
        "combined_all_ckd_tabnet_predictions_",
        "combined_none_tabnet_predictions_"
    };
    
    bool outputsFound = false;
    for (const auto& prefix : expectedOutputs) {
        // Check for files with this prefix created in the last 5 minutes
        for (const auto& entry : fs::directory_iterator("Data/new_predictions")) {
            std::string filename = entry.path().filename().string();
            if (filename.find(prefix) == 0) {
                fs::file_time_type fileTime = fs::last_write_time(entry.path());
                auto now = fs::file_time_type::clock::now();
                auto diff = std::chrono::duration_cast<std::chrono::minutes>(now - fileTime).count();
                if (diff < 5) { // File created in last 5 minutes
                    outputsFound = true;
                    std::cout << "[INFO] Found output file: " << filename << "\n";
                    break;
                }
            }
        }
    }
    
    if (!outputsFound) {
        std::cerr << "[WARNING] No recent output files found. Inference may have failed.\n";
    }
    
    return true;
}

//-----------------------------------------------------------------------------------
// main()
//-----------------------------------------------------------------------------------
int main(int argc, char* argv[])
{
    // Start timing and progress tracking
    gProgress.updateStage("Initializing");
    
    // 1. Parse command-line arguments
    int populationSize;
    bool enableXAI;
    bool perfMode;
    bool extremePerf;
    float memTargetPercent;
    float cpuTargetPercent;
    unsigned int userThreads;
    bool forceCPU;  // Added variable
    
    parseCommandLineArgs(argc, argv,
                          populationSize,
                          enableXAI,
                          perfMode,
                          extremePerf,
                          memTargetPercent,
                          cpuTargetPercent,
                          userThreads,
                          forceCPU);  // Added parameter
    
    // Initialize medical dictionaries before using them
    initializeDirectLookups();
    initializeElixhauserLookups();
    initializeObsAbnormalDirect();
    gProgress.stageProgress(100.0f);  // Complete initialization stage
    
    // Update progress to data generation stage
    gProgress.updateStage("GeneratingData");
    // 3. Always run Synthea to generate required data files
    // Ensure we have a valid population size (minimum 1)
    if (populationSize <= 0) {
        std::cout << "[WARNING] Invalid population size specified, defaulting to 100.\n";
        populationSize = 100;
    }   
    std::cout << "[INFO] Running Synthea to generate " << populationSize << " patient records...\n";
    runSynthea(populationSize);  // from Utilities.cpp
    gProgress.stageProgress(50.0f);  // Halfway through data generation
    
    copySyntheaOutput();         // from Utilities.cpp
    gProgress.stageProgress(100.0f);  // Complete data generation
    
    // Update progress to processing files stage
    gProgress.updateStage("ProcessingFiles");
    // 4. Identify CSV files (patients, conditions, etc.) - MODIFIED SECTION
    std::vector<std::string> patientFiles = findMostRecentCSVs("patients");
    std::vector<std::string> condFiles = findMostRecentCSVs("conditions");
    std::vector<std::string> encFiles = findMostRecentCSVs("encounters");
    std::vector<std::string> medFiles = findMostRecentCSVs("medications");
    std::vector<std::string> obsFiles = findMostRecentCSVs("observations");
    std::vector<std::string> procFiles = findMostRecentCSVs("procedures");
    
    // Log the files found
    std::cout << "[INFO] Found " << patientFiles.size() << " patient files\n";
    std::cout << "[INFO] Found " << condFiles.size() << " condition files\n";
    std::cout << "[INFO] Found " << encFiles.size() << " encounter files\n";
    std::cout << "[INFO] Found " << medFiles.size() << " medication files\n";
    std::cout << "[INFO] Found " << obsFiles.size() << " observation files\n";
    std::cout << "[INFO] Found " << procFiles.size() << " procedure files\n";
    gProgress.stageProgress(20.0f);  // File identification complete
    
    // 5. Read patient data
    std::cout << "[INFO] Reading patient records...\n";
    std::vector<PatientRecord> allPatients;
    try {
        for (auto &pf : patientFiles) {
            processPatientsInBatches(pf, [&](const PatientRecord &p){
                allPatients.push_back(p);
            }); 
        }   
    } catch (const std::exception &e) {
        std::cerr << "[ERROR] Failed to process patient files: " << e.what() << "\n";
        return 1;
    }   
    gProgress.stageProgress(40.0f);  // Patient processing complete
    
    // Update ages after loading patient data but before calculating health metrics
    std::cout << "[INFO] Calculating patient ages based on birthdate..." << std::endl;
    for (auto &p : allPatients) {
        p.Age = calculateAge(p.Birthdate);
    }
    gProgress.stageProgress(50.0f);  // Age calculation complete
    
    // Update to indices calculation stage
    gProgress.updateStage("CalculatingIndices");
    
    // 6. Use concurrency for calculating indexes/counters (Charlson, Elixhauser, meds, etc.)
    // Shared concurrency-safe counters
    ThreadSafeCounter charlsonCounter;
    ThreadSafeCounter elixhauserCounter;
    ThreadSafeCounter comorbCounter;
    ThreadSafeCounter hospitalCounter;
    ThreadSafeCounter medsCounter;
    ThreadSafeCounter abnormalObsCounter;
    
    // Conditions -> Charlson / Elixhauser / comorbidity
    std::cout << "[INFO] Processing conditions files (" << condFiles.size() << " files)...\n";
    int fileCounter = 0;
    bool verboseDebug = true;  // Enable verbose debug output to see what's happening
    int debugCount = 0;         // Counter to limit the number of debug messages
    
    // Add a debug counter for code matches
    int totalConditions = 0;
    int matchedCharlson = 0;
    int matchedElixhauser = 0;
    int matchedDescription = 0;
    
    // Process conditions with enhanced debug output
    for (auto &condFile : condFiles) {
        fileCounter++;
        std::cout << "[INFO] Processing condition file " << fileCounter << "/" << condFiles.size() << ": " 
                  << condFile << std::endl;
        
        processConditionsInBatches(condFile, [&](const ConditionRow &cRow) {
            totalConditions++;
             
            // Debug output for first 20 conditions
            if (debugCount < 20) {
                std::cout << "[DEBUG] Processing condition: " << cRow.CODE << " - " << cRow.DESCRIPTION << std::endl;
                debugCount++;
            }
             
            // Try exact code match first
            auto charlsonIt = CHARLSON_CODE_TO_WEIGHT.find(cRow.CODE);
            if (charlsonIt != CHARLSON_CODE_TO_WEIGHT.end()) {
                charlsonCounter.addFloat(cRow.PATIENT, charlsonIt->second);
                matchedCharlson++;
                if (debugCount < 40) {
                    std::cout << "[DEBUG] Added Charlson weight " << charlsonIt->second 
                            << " for patient " << cRow.PATIENT 
                            << " (code match: " << cRow.CODE << ")"<< std::endl;
                    debugCount++;
                }
            }
             
            auto elixhauserIt = ELIXHAUSER_CODE_TO_WEIGHT.find(cRow.CODE);
            if (elixhauserIt != ELIXHAUSER_CODE_TO_WEIGHT.end()) {
                elixhauserCounter.addFloat(cRow.PATIENT, elixhauserIt->second);
                matchedElixhauser++;
            }
             
            // Try prefix match if exact match fails
            if (charlsonIt == CHARLSON_CODE_TO_WEIGHT.end() && cRow.CODE.length() >= 3) {
                std::string prefix = cRow.CODE.substr(0, 3);
                charlsonIt = CHARLSON_CODE_TO_WEIGHT.find(prefix);
                if (charlsonIt != CHARLSON_CODE_TO_WEIGHT.end()) {
                    charlsonCounter.addFloat(cRow.PATIENT, charlsonIt->second);
                    matchedCharlson++;
                    if (debugCount < 60) {
                        std::cout << "[DEBUG] Added Charlson weight " << charlsonIt->second 
                                << " for patient " << cRow.PATIENT 
                                << " (prefix match: " << prefix << " from " << cRow.CODE << ")" << std::endl;
                        debugCount++;
                    }
                }
            }
             
            // Normalize description and try text matching (like Python's approach)
            std::string lowerDesc = cRow.DESCRIPTION;
            std::transform(lowerDesc.begin(), lowerDesc.end(), lowerDesc.begin(), 
                          [](unsigned char c){ return std::tolower(c); });
                          
            // Check for keywords in description like Python
            if (lowerDesc.find("diabetes") != std::string::npos) {
                charlsonCounter.addFloat(cRow.PATIENT, 2.0f); // Match Python weight of 2
                elixhauserCounter.addFloat(cRow.PATIENT, 0.5f);
                matchedDescription++;
                if (debugCount < 80) {
                    std::cout << "[DEBUG] Added diabetes weight via description match for patient "
                              << cRow.PATIENT << std::endl;
                    debugCount++;
                }
            }
            else if (lowerDesc.find("heart failure") != std::string::npos) {
                charlsonCounter.addFloat(cRow.PATIENT, 3.0f); // Match Python cardiovascular weight
                elixhauserCounter.addFloat(cRow.PATIENT, 1.5f);
                matchedDescription++;
            }
            else if (lowerDesc.find("copd") != std::string::npos || 
                     lowerDesc.find("chronic obstructive pulmonary") != std::string::npos) {
                charlsonCounter.addFloat(cRow.PATIENT, 2.0f); // Match Python respiratory weight
                elixhauserCounter.addFloat(cRow.PATIENT, 0.9f);
                matchedDescription++;
            }
        });
        
        // Update progress based on file processing
        float conditionProgress = (static_cast<float>(fileCounter) / condFiles.size()) * 30.0f;
        gProgress.stageProgress(conditionProgress);  // 30% of index calculation is conditions
    }
    
    // Print statistics about condition processing
    std::cout << "[INFO] Condition processing stats:" << std::endl;
    std::cout << "  Total conditions: " << totalConditions << std::endl;
    std::cout << "  Matched Charlson code: " << matchedCharlson << " (" 
              << (matchedCharlson * 100.0f / totalConditions) << "%)" << std::endl;
    std::cout << "  Matched Elixhauser code: " << matchedElixhauser << " (" 
              << (matchedElixhauser * 100.0f / totalConditions) << "%)" << std::endl;
    std::cout << "  Matched by description: " << matchedDescription << " (" 
              << (matchedDescription * 100.0f / totalConditions) << "%)" << std::endl;

    std::cout << std::endl;
    
    // Encounters -> hospitalization count
    fileCounter = 0;
    for (auto &encFile : encFiles) {
        fileCounter++;
        processEncountersInBatches(encFile, [&](const EncounterRow &enc){
            if (enc.ENCOUNTERCLASS == "inpatient") {
                hospitalCounter.increment(enc.PATIENT);
            }   
        });
        
        // Update progress based on file processing
        float encounterProgress = 30.0f + (static_cast<float>(fileCounter) / encFiles.size()) * 20.0f;
        gProgress.stageProgress(encounterProgress);  // 20% of index calculation is encounters
    }   
    
    // Medications -> medication count
    fileCounter = 0;
    for (auto &mFile : medFiles) {
        fileCounter++;
        processMedicationsInBatches(mFile, [&](const MedicationRow &mr){
            // Each line can be considered a medication row
            medsCounter.increment(mr.PATIENT);
        });
        
        // Update progress based on file processing
        float medProgress = 50.0f + (static_cast<float>(fileCounter) / medFiles.size()) * 20.0f;
        gProgress.stageProgress(medProgress);  // 20% of index calculation is medications
    }   
    
    // Observations -> count abnormal observations
    std::cout << "[INFO] Processing observation files...\n";
    size_t nonNumericCount = 0;
    std::set<std::string> uniqueNonNumericDescriptions;
    std::map<std::string, int> nonNumericByDescription;
    bool verboseWarnings = false;  // Set to true to see individual warnings
    
    fileCounter = 0;
    for (auto &oFile : obsFiles) {
        fileCounter++;
        processObservationsInBatches(oFile, [&](const ObservationRow &obs){
            try {
                double value = std::stod(obs.VALUE);
                if (isAbnormalObsFast(obs.DESCRIPTION, value)) {
                    abnormalObsCounter.increment(obs.PATIENT);
                }
            } catch (const std::exception& e) {
                // Track non-numeric values instead of printing each warning
                nonNumericCount++;
                uniqueNonNumericDescriptions.insert(obs.DESCRIPTION);
                nonNumericByDescription[obs.DESCRIPTION]++;
                // Only print individual warnings if verbose mode is enabled
                if (verboseWarnings) {
                    std::cerr << "[WARNING] Non-numeric observation value: " << obs.VALUE 
                              << " for description: " << obs.DESCRIPTION << "\n";
                }
            }
        });
        
        // Update progress based on file processing
        float obsProgress = 70.0f + (static_cast<float>(fileCounter) / obsFiles.size()) * 20.0f;
        gProgress.stageProgress(obsProgress);  // 20% of index calculation is observations
    }   
    
    // Print a summary of non-numeric observations
    if (nonNumericCount > 0) {
        std::cout << "[WARNING] Found " << nonNumericCount << " non-numeric observation values across " 
                  << uniqueNonNumericDescriptions.size() << " different description types.\n";
        // Optionally show top descriptions with non-numeric values
        std::cout << "[INFO] Top description with non-numeric values: \n";
        std::vector<std::pair<std::string, int>> sortedDescriptions(
            nonNumericByDescription.begin(), nonNumericByDescription.end());
        std::sort(sortedDescriptions.begin(), sortedDescriptions.end(),
            [](const auto& a, const auto& b) { return a.second > b.second; });
        const int maxToShow = 3;  // Limit the number of descriptions shown
        for (int i = 0; i < std::min(maxToShow, static_cast<int>(sortedDescriptions.size())); ++i) {
            std::cout << "  - Description ID: " << sortedDescriptions[i].first 
                      << " (" << sortedDescriptions[i].second << " occurrences)\n";
        }
    }   
    
    // Debug counters before updating patients
    std::cout << "[DEBUG] First 5 patients from charlsonCounter:\n";
    debugCount = 0;  // Reset the counter instead of redefining it
    for (auto& p : allPatients) {
        if (debugCount < 5) {
            std::cout << "   Patient " << p.Id << ": CharlsonIndex=" 
                      << charlsonCounter.getFloat(p.Id) 
                      << ", Hospitalizations=" << hospitalCounter.getInt(p.Id)
                      << ", Medications=" << medsCounter.getInt(p.Id) << "\n";
            debugCount++;
        }
    }
    
    // Debug counter values after processing all files
    std::cout << "[DEBUG] Random sample of counter values:\n";
    for (int i = 0; i < 10 && i < allPatients.size(); ++i) {
        std::string patientId = allPatients[i].Id;
        std::cout << "Patient " << patientId << ":\n"
                  << "  Charlson: " << charlsonCounter.getFloat(patientId) << "\n"
                  << "  Elixhauser: " << elixhauserCounter.getFloat(patientId) << "\n" 
                  << "  Comorbidity: " << comorbCounter.getFloat(patientId) << "\n"
                  << "  Hospitalizations: " << hospitalCounter.getInt(patientId) << "\n"
                  << "  Medications: " << medsCounter.getInt(patientId) << "\n"
                  << "  Abnormal Obs: " << abnormalObsCounter.getInt(patientId) << "\n";
    }
    
    // 7. Update allPatients with these concurrency-safe counters
    // Using original capitalized field names from PatientRecord struct
    for (auto &p : allPatients) {
        p.CharlsonIndex              = charlsonCounter.getFloat(p.Id);  // Use getFloat instead of casting from getInt
        p.ElixhauserIndex            = elixhauserCounter.getFloat(p.Id);  // Use getFloat directly
        p.Comorbidity_Score          = comorbCounter.getFloat(p.Id);  // Use getFloat directly
        p.Hospitalizations_Count     = hospitalCounter.getInt(p.Id);
        p.Medications_Count          = medsCounter.getInt(p.Id);
        p.Abnormal_Observations_Count= abnormalObsCounter.getInt(p.Id);
        
        // Recompute health index
        p.Health_Index = computeHealthIndex(p);
    }
    
    gProgress.stageProgress(90.0f);  // Most of index calculation is done
    
    // Debug the updated patient records
    std::cout << "[DEBUG] First 5 patient records after updating:\n";
    debugCount = 0;  // Reset the counter again
    for (auto& p : allPatients) {
        if (debugCount < 5) {
            std::cout << "   Patient " << p.Id << ": CharlsonIndex=" << p.CharlsonIndex 
                      << ", Hospitalizations=" << p.Hospitalizations_Count 
                      << ", Medications=" << p.Medications_Count << "\n";
            debugCount++;
        }
    }
    
    // 8. (Optional) Identify subsets (diabetes, CKD, etc.) using PatientSubsets
    std::cout << "[INFO] Loading ConditionRows for subset identification...\n";
    std::vector<ConditionRow> allConds;
    for (auto &condFile : condFiles) {
        processConditionsInBatches(condFile, [&](const ConditionRow &c){
            allConds.push_back(c);
        }); 
    }   
    
    // Find diabetic patients with more comprehensive checks
    std::set<std::string> diabeticSet;
    std::set<std::string> ckdSet;
    
    // Check both CODE and DESCRIPTION for better identification
    std::cout << "[INFO] Identifying patient subgroups with enhanced criteria...\n";
    for (const auto& cond : allConds) {
        std::string code = cond.CODE;
        std::string description = cond.DESCRIPTION;
        
        // Convert to lowercase for case-insensitive matching
        std::transform(description.begin(), description.end(), description.begin(), 
                      [](unsigned char c){ return std::tolower(c); });
        
        // Check for diabetes - match Python implementation (subset_utils.py)
        // Python uses: mask = conditions["DESCRIPTION"].str.lower().str.contains("diabetes", na=False)
        if (description.find("diabetes") != std::string::npos) {
            diabeticSet.insert(cond.PATIENT);
        }   
        
        // Check for CKD - match Python implementation (subset_ckd)
        // Python defines the same exact codes and case-insensitive text search
        std::set<std::string> ckdCodes = {"431855005", "431856006", "433144002", "431857002", "46177005"};
        
        if (ckdCodes.find(code) != ckdCodes.end() || 
            description.find("chronic kidney disease") != std::string::npos) {
            ckdSet.insert(cond.PATIENT);
        }
    }   
    
    // Remove arbitrary percentage allocation and replace with proper fallback check
    if (diabeticSet.empty()) {
        std::cout << "[WARNING] No diabetic patients found by condition codes/descriptions.\n";
        std::cout << "[INFO] This might indicate issues with the condition data or coding system.\n";
    }   
    std::cout << "[INFO] Found " << diabeticSet.size() << " diabetic patients using clinical criteria.\n";
    std::cout << "[INFO] Found " << ckdSet.size() << " CKD patients using clinical criteria.\n";
    
    // For verification, we can also log patient IDs to a file for debugging
    std::ofstream diabeticFile("diabetic_patients.txt");
    if (diabeticFile.is_open()) {
        diabeticFile << "# Diabetic patients identified in C++\n";
        for (const auto& id : diabeticSet) {
            diabeticFile << id << "\n";
        }   
        diabeticFile.close();
        std::cout << "[INFO] Wrote diabetic patient IDs to diabetic_patients.txt\n";
    }   
    
    gProgress.stageProgress(100.0f);  // Complete indices calculation
    
    // Update to feature normalization stage
    gProgress.updateStage("NormalizingFeatures");
    
    // 9. Create feature CSV for inference or training
    std::string featureConfig = "combined_all"; 
    // Get expected features with exact capitalization 
    auto featureCols = getRequiredFeatures(); 
    // Add this before writeFeaturesCSV to normalize features
    std::cout << "[INFO] Normalizing features to match Python scaling..." << std::endl;
    normalizePatientFeatures(allPatients);  // Add this function to FeatureUtils.cpp
    gProgress.stageProgress(40.0f);  // Normalization complete
    
    writeFeaturesCSV(allPatients, "PatientFeatures.csv", featureCols);
    gProgress.stageProgress(60.0f);  // Features CSV written
    
    // Validate the feature CSV before running predictions
    validateFeatureCSV("PatientFeatures.csv");
    
    // Still write a comprehensive CSV of everything including Health_Index for other purposes    
    saveFinalDataCSV(allPatients, "AllPatientsData.csv");
    gProgress.stageProgress(90.0f);  // CSV validation complete
    
    // Before running predictions, ensure the Python script exists
    // Check multiple locations for required Python scripts
    fs::path pythonScriptPath = "run_patient_group_predictions.py";
    if (!fs::exists(pythonScriptPath)) {
        // Try SCRIPT_DIR location
        pythonScriptPath = fs::path(SCRIPT_DIR) / "run_patient_group_predictions.py";
        if (!fs::exists(pythonScriptPath)) {
            // Try vitai_scripts subdirectory
            pythonScriptPath = "vitai_scripts/run_patient_group_predictions.py";
            if (!fs::exists(pythonScriptPath)) {
                std::cerr << "[ERROR] Required Python script not found: run_patient_group_predictions.py\n";
                return 1;
            }
        }
    }
    std::cout << "[INFO] Found Python script at: " << pythonScriptPath << std::endl;
    
    // Run model inspector to check our model requirements
    std::cout << "[INFO] Running model inspector to verify embedding dimensions...\n";
    std::system("python model_inspector.py");
    
    gProgress.stageProgress(100.0f);  // Feature preparation complete
    
    // Update to predictions stage
    gProgress.updateStage("RunningPredictions");
    
    // 10. Call Python script for patient grouping and multi-model predictions
    bool ok = false;

    // First try the adapted tabnet solution
    std::cout << "[INFO] Running inference with TabNet adapter...\n";
    // Change the model parameter to match what tabnet_adapter.py expects
    std::string adapterCmd = "python tabnet_adapter.py --input=\"" + fs::absolute("PatientFeatures.csv").string() + 
                           "\" --model=\"combined_diabetes_tabnet\"";
    // Fix: Use output-dir instead of output_dir, and remove the = sign
    adapterCmd += " --output-dir \"Data/new_predictions\"";
    if (forceCPU) {
        adapterCmd += " --force-cpu";
    }
    int adapterResult = std::system(adapterCmd.c_str());
    if (adapterResult == 0) {
        ok = true;
        std::cout << "[INFO] TabNet adapter ran successfully.\n";
        gProgress.stageProgress(70.0f);  // TabNet success
    } else {
        std::cout << "[INFO] TabNet adapter failed, falling back to standard method.\n";
        // Fall back to standard method
        ok = runMultiModelPredictions("PatientFeatures.csv", forceCPU);
        if (ok) {
            gProgress.stageProgress(70.0f);  // Standard method success
        }
    }
    
    // Update predictions with final steps (100%)
    gProgress.stageProgress(100.0f);
    
    // (Optional) If XAI is enabled, call XAI script but don't track as a separate stage
    if (enableXAI) {
        std::cout << "[INFO] Running XAI for each patient group...\n";
        // Construct the command for XAI
        std::ostringstream xaiCmd;
        xaiCmd << "python run_xai_analysis.py";
        if (forceCPU || GPU_INFERENCE_FAILED) {  // Force CPU for XAI if GPU inference failed
            xaiCmd << " --force-cpu";
        }   
        int xaiRet = std::system(xaiCmd.str().c_str());
        if (xaiRet != 0) {
            std::cerr << "[ERROR] XAI analysis failed with code: " << xaiRet << "\n";
        }   
    }   
    
    // Mark completion
    gProgress.updateStage("Completed", 100.0f);
    
    // Update return code based on inference success
    if (GPU_INFERENCE_FAILED) {
        std::cout << "[INFO] GenerateAndPredict completed with inference issues. Check logs for details.\n";
        return 1;  // Return non-zero to indicate issues occurred
    } else {
        std::cout << "[INFO] GenerateAndPredict completed successfully.\n";
        return 0;
    }   
}

// Function to calculate age based on birthdate - moved before main
int calculateAge(const std::string& birthdate) {
    if (birthdate.empty() || birthdate.length() < 10) {
        return 30; // Default age if birthdate is invalid
    }
    
    try {
        // Extract year from birthdate (format: YYYY-MM-DD)
        int birthYear = std::stoi(birthdate.substr(0, 4));
        
        // Get current year
        auto now = std::chrono::system_clock::now();
        std::time_t now_c = std::chrono::system_clock::to_time_t(now);
        struct tm* currentTime = std::localtime(&now_c);
        int currentYear = currentTime->tm_year + 1900;
        
        // Calculate age
        int age = currentYear - birthYear;
        
        // Basic validation
        if (age < 0) age = 0;
        if (age > 120) age = 120;
        
        return age;
    } catch (const std::exception& e) {
        std::cerr << "[WARNING] Error calculating age from birthdate: " << birthdate << ": " << e.what() << std::endl;
        return 30; // Default on error
    }
}

// Add this helper function to get timestamp string in the same format as Python
std::string getCurrentTimestampString() {
    auto now = std::chrono::system_clock::now();
    std::time_t now_c = std::chrono::system_clock::to_time_t(now);
    struct tm local_tm;
#ifdef _WIN32
    localtime_s(&local_tm, &now_c);
#else
    localtime_r(&local_tm, &now_c);
#endif
    
    char buffer[20];
    std::strftime(buffer, sizeof(buffer), "%Y%m%d_%H%M%S", &local_tm);
    return std::string(buffer);
}

# ========================================
# File: GenerateAndPredict_old.cpp
# ========================================
/*****************************************************
 * GenerateAndPredict.cpp
 *
 * C++ program replicating the logic of:
 *   1) data_preprocessing.py (merge old & new CSVs, marking new data as NewData)
 *   2) health_index.py (computing comorbidity-based features + Health_Index)
 *   3) data_prep.py (merging Charlson/Elixhauser, final integrated dataset)
 *   4) subset_utils.py (filter: diabetes/ckd/none)
 *   5) feature_utils.py (select columns: composite, cci, eci, combined, etc.)
 *   6) final "generate_new_patients_and_predict.py" pipeline
 *   7) Embedded Python calls for TabNet model inference + optional XAI
 *
 * Charlson Comorbidity Index now uses a full dictionary-based approach
 * (no CSV file). We replicate the "SNOMED_TO_CHARLSON" and category weights
 * from the Python script you provided.
 *
 * Author: Imran Feisal
 * Date: 08/03/2025
 * To build the file use command:
 * cl /EHsc /std:c++17 GenerateAndPredict.cpp ^ /I"C:\Users\imran\miniconda3\envs\tf_gpu_env\include" ^ /link /LIBPATH:"C:\Users\imran\miniconda3\envs\tf_gpu_env\libs" python39.lib /MACHINE:X64
 * Usage: 
 * GenerateAndPredict.exe --population=100
 * or
 * GenerateAndPredict.exe --population=100 --enable-xai
 * 
 *****************************************************/








/******************************************
 * TODO: Confirm if the logic used for the health index is similar to
 * the one used in helath_index.py
 ******************************************/
#include <Python.h> // For embedded Python
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <algorithm>
#include <functional>
#include <sys/stat.h>
#include <cstdlib>
#include <cstdio>
#include <chrono>
#include <ctime>
#include <filesystem> // C++17
namespace fs = std::filesystem;

// For CSV parsing (using an external single-header CSV library)
// #define CSV_IO_NO_THREAD 
#define CSV_IMPLEMENTATION
#include "csv.hpp"

#ifdef _WIN32
  #include <direct.h>
  #define MKDIR(x) _mkdir(x)
#else
  #include <unistd.h>
  #define MKDIR(x) mkdir(x, 0755)
#endif

/****************************************************
 * Global Config & Structures
 ****************************************************/
static const std::string DATA_DIR  = "Data";
static const std::string SYN_DIR   = "synthea-master";
static const std::string SYN_OUT   = "output/csv";

// Similar to your Python MODEL_CONFIG_MAP: model_id -> (subset, feature_config)
struct ModelConfig {
    std::string subset;
    std::string feature_config;
};
static std::map<std::string, ModelConfig> MODEL_CONFIG_MAP = {
    {"combined_diabetes_tabnet", {"diabetes", "combined"}},
    {"combined_all_ckd_tabnet",  {"ckd",      "combined_all"}},
    {"combined_none_tabnet",     {"none",     "combined"}}
};

// Data structures to hold loaded records
struct PatientRecord {
    std::string Id;
    std::string BIRTHDATE;
    std::string DEATHDATE;
    std::string GENDER;
    std::string RACE;
    std::string ETHNICITY;
    double HEALTHCARE_EXPENSES=0.0;
    double HEALTHCARE_COVERAGE=0.0;
    double INCOME=0.0;
    std::string MARITAL;
    bool   NewData=false;   // Mark if loaded from a "_diff_" file

    // Simplistic approach for age & deceased
    double AGE=0.0;
    bool   DECEASED=false;

    // Charlson & Elixhauser indices
    double CharlsonIndex=0.0;
    double ElixhauserIndex=0.0;

    // Additional metrics
    double Comorbidity_Score=0.0;
    int    Hospitalizations_Count=0;
    int    Medications_Count=0;
    int    Abnormal_Observations_Count=0;

    // Final "Health_Index"
    double Health_Index=0.0;
};

struct ConditionRow {
    std::string PATIENT;
    std::string CODE;
    std::string DESCRIPTION;
};
struct EncounterRow {
    std::string Id;
    std::string PATIENT;
    std::string ENCOUNTERCLASS;
};
struct MedicationRow {
    std::string PATIENT;
    std::string ENCOUNTER;
    std::string CODE;
    std::string DESCRIPTION;
};
struct ObservationRow {
    std::string PATIENT;
    std::string ENCOUNTER;
    std::string CODE;
    std::string DESCRIPTION;
    double VALUE=0.0;
    std::string UNITS;
};
struct ProcedureRow {
    std::string PATIENT;
    std::string ENCOUNTER;
    std::string CODE;
    std::string DESCRIPTION;
};

/****************************************************
 * Utility: mkdir, timestamp, runSynthea, copySynthea
 ****************************************************/
static void makeDirIfNeeded(const std::string &dir) {
    struct stat st;
    if (stat(dir.c_str(), &st) != 0) {
#ifdef _WIN32
        _mkdir(dir.c_str());
#else
        mkdir(dir.c_str(), 0755);
#endif
    }
}

static std::string getTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto t_c = std::chrono::system_clock::to_time_t(now);
    struct tm *parts = std::localtime(&t_c);
    char buf[64];
    std::strftime(buf, sizeof(buf), "%Y%m%d_%H%M%S", parts);
    return std::string(buf);
}

static void runSynthea(int popSize) {
#ifdef _WIN32
    // Windows example
    std::string cmd = "cd " + SYN_DIR + " && run_synthea.bat -p " + std::to_string(popSize);
#else
    // Linux/macOS example
    std::string cmd = "cd " + SYN_DIR + " && ./run_synthea -p " + std::to_string(popSize);
#endif
    std::cout << "[INFO] Running Synthea: " << cmd << "\n";
    int ret = std::system(cmd.c_str());
    if (ret != 0) {
        std::cerr << "[ERROR] Synthea generation failed.\n";
        std::exit(1);
    }
    std::cout << "[INFO] Synthea generation complete.\n";
}

// Copy the main Synthea output CSVs to our Data directory with a timestamp 
static void copySyntheaOutput() {
   // e.g. "synthea-master/output/csv"
   fs::path synOutput = fs::path(SYN_DIR) / SYN_OUT;

   // Make sure the Synthea output dir actually exists:
   if (!fs::exists(synOutput)) {
       std::cerr << "[ERROR] Synthea output dir " << synOutput << " not found.\n";
       std::exit(1);
   }
   makeDirIfNeeded(DATA_DIR); // keep your existing mkdir logic or use filesystem as well

   // The main CSV files we want to copy
   std::vector<std::string> needed = {
       "patients.csv", "encounters.csv", "conditions.csv",
       "medications.csv", "observations.csv", "procedures.csv"
   };

   std::string stamp = getTimestamp(); // your existing function
   for (auto &fname : needed) {
       fs::path src = synOutput / fname;
       if (!fs::exists(src)) {
           std::cerr << "[WARN] Missing " << fname << " in Synthea output.\n";
           continue;
       }
       // e.g. "patients_diff_20250309_165742.csv"
       auto dotPos = fname.rfind('.');
       std::string base = (dotPos == std::string::npos
                           ? fname
                           : fname.substr(0, dotPos));
       std::string ext  = (dotPos == std::string::npos
                           ? ""
                           : fname.substr(dotPos));
       std::string newName = base + "_diff_" + stamp + ext;

       fs::path dst = fs::path(DATA_DIR) / newName;

       std::cout << "[INFO] Copying " << src << " => " << dst << "\n";
       try {
           // Overwrites if already exists:
           fs::copy_file(src, dst, fs::copy_options::overwrite_existing);
       } catch (const fs::filesystem_error &ex) {
           std::cerr << "[ERROR] copy failed: " << ex.what() << "\n";
       }
   }
}

/****************************************************
 * Helpers to load CSVs
 ****************************************************/

// check if file name includes "_diff_"
static bool isDiffFile(const std::string &fname) {
    return (fname.find("_diff_") != std::string::npos);
}

// Returns all CSV files in the Data/ directory that start with `prefix` and end with ".csv".
// e.g. If prefix="patients", it finds "patients.csv", "patients_diff_20250309_170905.csv", etc.
static std::vector<std::string> listCSVFiles(const std::string &prefix)
{
   std::vector<std::string> found;

   // Point to the "Data" directory (or use a global constant if you prefer)
   fs::path dataDir("Data");

   // Check if Data/ exists and is a directory
   if (!fs::exists(dataDir) || !fs::is_directory(dataDir))
   {
       std::cerr << "[ERROR] Data directory not found or not a directory: " 
                 << dataDir << std::endl;
       return found;
   }

   // Iterate over files in Data/
   for (auto &entry : fs::directory_iterator(dataDir))
   {
       if (!entry.is_regular_file()) 
           continue;  // skip directories, etc.

       // Extract just the filename (e.g. "patients_diff_20250309_170905.csv")
       std::string filename = entry.path().filename().string();

       // Check if filename starts with `prefix` and ends with ".csv"
       //  - rfind(prefix, 0) == 0 means the prefix is found at position 0 (i.e., "starts with")
       //  - compare(...) == 0 on the last 4 chars ensures ".csv" at the end
       if (filename.rfind(prefix, 0) == 0 && 
           filename.size() > 4 &&
           filename.compare(filename.size() - 4, 4, ".csv") == 0)
       {
           // Full path to the file
           found.push_back(entry.path().string());
       }
   }
   return found;
}

// 1) Load patients
static void loadPatients(std::vector<PatientRecord> &allPatients) {
    auto patientFiles = listCSVFiles("patients"); 
    for (auto &path : patientFiles) {
        bool diff = isDiffFile(path);
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                PatientRecord p;
                p.Id        = row["Id"].get<>();
                p.BIRTHDATE = row["BIRTHDATE"].get<>();
                p.DEATHDATE = row["DEATHDATE"].get<>();
                p.GENDER    = row["GENDER"].get<>();
                p.RACE      = row["RACE"].get<>();
                p.ETHNICITY = row["ETHNICITY"].get<>();
                p.MARITAL   = row["MARITAL"].get<>();

                try { p.HEALTHCARE_EXPENSES = row["HEALTHCARE_EXPENSES"].get<double>(); } catch(...) {}
                try { p.HEALTHCARE_COVERAGE = row["HEALTHCARE_COVERAGE"].get<double>(); } catch(...) {}
                try { p.INCOME = row["INCOME"].get<double>(); } catch(...) {}

                p.NewData = diff;
                if (!p.DEATHDATE.empty() && p.DEATHDATE != "NaN") {
                    p.DECEASED = true;
                }
                // naive approach for AGE
                p.AGE = 50.0;
                allPatients.push_back(p);
            }
        } catch(...) {
            std::cerr << "[ERROR] parsing " << path << "\n";
        }
    }
}

// 2) Load conditions, encounters, meds, obs, procs
static void loadConditions(std::vector<ConditionRow> &conds) {
    auto condFiles = listCSVFiles("conditions");
    for (auto &path : condFiles) {
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                ConditionRow c;
                c.PATIENT     = row["PATIENT"].get<>();
                c.CODE        = row["CODE"].get<>();
                c.DESCRIPTION = row["DESCRIPTION"].get<>();
                conds.push_back(c);
            }
        } catch(...) {}
    }
}

static void loadEncounters(std::vector<EncounterRow> &encs) {
    auto encFiles = listCSVFiles("encounters");
    for (auto &path : encFiles) {
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                EncounterRow e;
                e.Id             = row["Id"].get<>();
                e.PATIENT        = row["PATIENT"].get<>();
                e.ENCOUNTERCLASS = row["ENCOUNTERCLASS"].get<>();
                encs.push_back(e);
            }
        } catch(...) {}
    }
}

static void loadMedications(std::vector<MedicationRow> &meds) {
    auto files = listCSVFiles("medications");
    for (auto &path : files) {
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                MedicationRow m;
                m.PATIENT     = row["PATIENT"].get<>();
                m.ENCOUNTER   = row["ENCOUNTER"].get<>();
                m.CODE        = row["CODE"].get<>();
                m.DESCRIPTION = row["DESCRIPTION"].get<>();
                meds.push_back(m);
            }
        } catch(...) {}
    }
}

static void loadObservations(std::vector<ObservationRow> &obs) {
    auto files = listCSVFiles("observations");
    for (auto &path : files) {
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                ObservationRow o;
                o.PATIENT     = row["PATIENT"].get<>();
                o.ENCOUNTER   = row["ENCOUNTER"].get<>();
                o.CODE        = row["CODE"].get<>();
                o.DESCRIPTION = row["DESCRIPTION"].get<>();
                try {
                    o.VALUE = row["VALUE"].get<double>();
                } catch(...) {
                    o.VALUE = 0.0;
                }
                o.UNITS = row["UNITS"].get<>();
                obs.push_back(o);
            }
        } catch(...) {}
    }
}

static void loadProcedures(std::vector<ProcedureRow> &procs) {
    auto files = listCSVFiles("procedures");
    for (auto &path : files) {
        try {
            csv::CSVReader rd(path);
            for (auto &row : rd) {
                ProcedureRow p;
                p.PATIENT     = row["PATIENT"].get<>();
                p.ENCOUNTER   = row["ENCOUNTER"].get<>();
                p.CODE        = row["CODE"].get<>();
                p.DESCRIPTION = row["DESCRIPTION"].get<>();
                procs.push_back(p);
            }
        } catch(...) {}
    }
}

/****************************************************
 * Charlson Comorbidity: dictionary-based approach
 * from your Python "charlson_comorbidity.py"
 ****************************************************/

// 1) Full SNOMED->CharlsonCategory mapping
static std::map<long long, std::string> SNOMED_TO_CHARLSON = {
    // MYOCARDIAL INFARCTION (weight 1)
    {22298006, "Myocardial infarction"},
    {401303003, "Myocardial infarction"},
    {401314000, "Myocardial infarction"},
    {129574000, "Myocardial infarction"},

    // CONGESTIVE HEART FAILURE (weight 1)
    {88805009,  "Congestive heart failure"},
    {84114007,  "Congestive heart failure"},

    // PERIPHERAL VASCULAR DISEASE (weight 1)
    // (No explicit codes in that snippet, so omitted)

    // CEREBROVASCULAR DISEASE (weight 1)
    {230690007, "Cerebrovascular disease"},

    // DEMENTIA (weight 1)
    {26929004,  "Dementia"},
    {230265002, "Dementia"},

    // CHRONIC PULMONARY DISEASE (weight 1)
    {185086009, "Chronic pulmonary disease"},
    {87433001,  "Chronic pulmonary disease"},
    {195967001, "Chronic pulmonary disease"},
    {233678006, "Chronic pulmonary disease"},

    // CONNECTIVE TISSUE DISEASE (weight 1)
    {69896004,  "Connective tissue disease"},
    {200936003, "Connective tissue disease"},

    // ULCER DISEASE (weight 1)
    // (No explicit codes in that snippet)

    // MILD LIVER DISEASE (weight 1)
    {128302006, "Mild liver disease"},
    {61977001,  "Mild liver disease"},

    // DIABETES WITHOUT END-ORGAN DAMAGE (weight 1)
    {44054006,  "Diabetes without end-organ damage"},

    // DIABETES WITH END-ORGAN DAMAGE (weight 2)
    {368581000119106LL, "Diabetes with end-organ damage"},
    {422034002,         "Diabetes with end-organ damage"},
    {127013003,         "Diabetes with end-organ damage"},
    {90781000119102LL,  "Diabetes with end-organ damage"},
    {157141000119108LL, "Diabetes with end-organ damage"},
    {60951000119105LL,  "Diabetes with end-organ damage"},
    {97331000119101LL,  "Diabetes with end-organ damage"},
    {1501000119109LL,   "Diabetes with end-organ damage"},
    {1551000119108LL,   "Diabetes with end-organ damage"},

    // HEMIPLEGIA/PARAPLEGIA (weight 2)
    // (No explicit codes in that snippet)

    // MODERATE OR SEVERE KIDNEY DISEASE (weight 2)
    {431855005, "Moderate or severe kidney disease"},
    {431856006, "Moderate or severe kidney disease"},
    {433144002, "Moderate or severe kidney disease"},
    {431857002, "Moderate or severe kidney disease"},
    {46177005,  "Moderate or severe kidney disease"},
    {129721000119106LL, "Moderate or severe kidney disease"},

    // ANY TUMOUR (weight 2)
    {254637007, "Any tumour, leukaemia, lymphoma"},
    {254632001, "Any tumour, leukaemia, lymphoma"},
    {93761005,  "Any tumour, leukaemia, lymphoma"},
    {363406005, "Any tumour, leukaemia, lymphoma"},
    {109838007, "Any tumour, leukaemia, lymphoma"},
    {126906006, "Any tumour, leukaemia, lymphoma"},
    {92691004,  "Any tumour, leukaemia, lymphoma"},
    {254837009, "Any tumour, leukaemia, lymphoma"},
    {109989006, "Any tumour, leukaemia, lymphoma"},
    {93143009,  "Any tumour, leukaemia, lymphoma"},
    {91861009,  "Any tumour, leukaemia, lymphoma"},

    // MODERATE OR SEVERE LIVER DISEASE (weight 3)
    // (No explicit codes in the snippet, but you can add if needed)

    // METASTATIC SOLID TUMOUR (weight 6)
    {94503003,  "Metastatic solid tumour"},
    {94260004,  "Metastatic solid tumour"},

    // AIDS/HIV (weight 6)
    {62479008,  "AIDS/HIV"},
    {86406008,  "AIDS/HIV"}
};

// 2) Category->CharlsonWeight
static std::map<std::string,int> CHARLSON_CATEGORY_WEIGHTS = {
    {"Myocardial infarction", 1},
    {"Congestive heart failure", 1},
    {"Peripheral vascular disease", 1},
    {"Cerebrovascular disease", 1},
    {"Dementia", 1},
    {"Chronic pulmonary disease", 1},
    {"Connective tissue disease", 1},
    {"Ulcer disease", 1},
    {"Mild liver disease", 1},
    {"Diabetes without end-organ damage", 1},

    {"Hemiplegia", 2},
    {"Moderate or severe kidney disease", 2},
    {"Diabetes with end-organ damage", 2},
    {"Any tumour, leukaemia, lymphoma", 2},

    {"Moderate or severe liver disease", 3},
    {"Metastatic solid tumour", 6},
    {"AIDS/HIV", 6}
};

/****************************************************
 * Elixhauser (unchanged from earlier approach)
 ****************************************************/
static std::map<long long, std::string> SNOMED_TO_ELIXHAUSER = {
   // Congestive Heart Failure
   {88805009,  "Congestive heart failure"},
   {84114007,  "Congestive heart failure"},

   // Cardiac Arrhythmias
   {49436004,  "Cardiac arrhythmias"},

   // Valvular Disease
   {48724000,  "Valvular disease"},
   {91434003,  "Pulmonic valve regurgitation"},
   {79619009,  "Mitral valve stenosis"},
   {111287006, "Tricuspid valve regurgitation"},
   {49915006,  "Tricuspid valve stenosis"},
   {60573004,  "Aortic valve stenosis"},
   {60234000,  "Aortic valve regurgitation"},

   // Pulmonary Circulation Disorders
   {65710008,  "Pulmonary circulation disorders"},
   {706870000, "Acute pulmonary embolism"},
   {67782005,  "Acute respiratory distress syndrome"},

   // Peripheral Vascular Disorders
   // NOTE: Overwritten by the next entry in the Python dictionary (key repeated)
   // {698754002, "Peripheral vascular disorders"},

   // Hypertension
   {59621000,  "Hypertension, uncomplicated"},

   // Paralysis
   // Overwrites the earlier "Peripheral vascular disorders" for 698754002
   {698754002, "Paralysis"},
   {128188000, "Paralysis"},

   // Other Neurological Disorders
   // NOTE: Overwritten by the next entry in the Python dictionary (key repeated)
   // {69896004,  "Other neurological disorders"},
   {128613002, "Seizure disorder"},

   // Chronic Pulmonary Disease
   {195967001, "Chronic pulmonary disease"},
   {233678006, "Chronic pulmonary disease"},

   // Diabetes, Complicated
   {368581000119106, "Diabetes, complicated"},
   {422034002,        "Diabetes, complicated"},
   {90781000119102,   "Diabetes, complicated"},

   // Diabetes, Uncomplicated
   {44054006,  "Diabetes, uncomplicated"},

   // Renal Failure
   {129721000119106, "Renal failure"},
   {433144002,       "Renal failure"},

   // Liver Disease
   {128302006, "Liver disease"},
   {61977001,  "Liver disease"},

   // Peptic Ulcer Disease
   // (Not identified in the dataset)

   // AIDS/HIV
   {62479008,  "AIDS/HIV"},
   {86406008,  "AIDS/HIV"},

   // Lymphoma
   {93143009,  "Lymphoma"},

   // Metastatic Cancer
   {94503003,  "Metastatic cancer"},
   {94260004,  "Metastatic cancer"},

   // Solid Tumour Without Metastasis
   {126906006, "Solid tumour without metastasis"},
   {254637007, "Solid tumour without metastasis"},

   // Rheumatoid Arthritis / Collagen Vascular Diseases
   // Overwrites the earlier "Other neurological disorders" for 69896004
   {69896004,  "Rheumatoid arthritis/collagen vascular diseases"},
   {200936003, "Rheumatoid arthritis/collagen vascular diseases"},

   // Coagulopathy
   {234466008, "Coagulopathy"},

   // Obesity
   {408512008, "Obesity"},
   {162864005, "Obesity"},

   // Weight Loss
   {278860009, "Weight loss"},

   // Fluid and Electrolyte Disorders
   {389087006, "Fluid and electrolyte disorders"},

   // Blood Loss Anaemia
   // (Not identified in the dataset)

   // Deficiency Anaemias
   {271737000, "Deficiency anaemias"},

   // Alcohol Abuse
   {7200002,   "Alcohol abuse"},

   // Drug Abuse
   {6525002,   "Drug abuse"},

   // Psychoses
   {47505003,  "Psychoses"},

   // Depression
   {370143000, "Depression"},
   {36923009,  "Depression"}
};


// We apply the typical van Walraven weighting:
static std::map<std::string,int> ELIXHAUSER_CATEGORY_WEIGHTS = {
   {"Congestive heart failure", 7},
   {"Cardiac arrhythmias", 5},
   {"Valvular disease", 4},
   {"Pulmonary circulation disorders", 6},
   {"Peripheral vascular disorders", 2},
   {"Hypertension, uncomplicated", -1},
   {"Hypertension, complicated", 0},
   {"Paralysis", 7},
   {"Other neurological disorders", 6},
   {"Chronic pulmonary disease", 3},
   {"Diabetes, uncomplicated", 0},
   {"Diabetes, complicated", 7},
   {"Hypothyroidism", 0},
   {"Renal failure", 5},
   {"Liver disease", 11},
   {"Peptic ulcer disease", 0},
   {"AIDS/HIV", 0},
   {"Lymphoma", 9},
   {"Metastatic cancer", 14},
   {"Solid tumour without metastasis", 8},
   {"Rheumatoid arthritis/collagen vascular diseases", 4},
   {"Coagulopathy", 11},
   {"Obesity", 0},
   {"Weight loss", 6},
   {"Fluid and electrolyte disorders", 5},
   {"Blood loss anaemia", 3},
   {"Deficiency anaemias", 0},
   {"Alcohol abuse", 0},
   {"Drug abuse", 0},
   {"Psychoses", 0},
   {"Depression", -3}
};

/****************************************************
 * 1) Compute Charlson (dictionary-based)
 ****************************************************/
static void computeCharlsonIndex(const std::vector<ConditionRow> &conds,
                                 std::unordered_map<std::string,double> &charlsonScore)
{
    // We'll store the best weight for each (patient, category).
    // i.e., if a patient has multiple codes in the same category,
    // we only count that category once and take the max weight if needed.
    // But typically Charlson is "one category = fixed weight".
    // This approach matches the Python logic of grouping by (PATIENT, category).
    std::map<std::pair<std::string,std::string>, int> patCatWeight; 

    for (auto &c : conds) {
        // Convert code to a long long
        long long codeLL=0;
        try {
            codeLL = std::stoll(c.CODE);
        } catch(...) {
            // if code is not numeric
            continue;
        }
        // Look up category
        auto it = SNOMED_TO_CHARLSON.find(codeLL);
        if (it == SNOMED_TO_CHARLSON.end()) {
            continue; // code not in dictionary
        }
        const std::string &category = it->second;

        // Category -> weight
        auto wIt = CHARLSON_CATEGORY_WEIGHTS.find(category);
        if (wIt == CHARLSON_CATEGORY_WEIGHTS.end()) {
            continue;
        }
        int weight = wIt->second;

        auto key = std::make_pair(c.PATIENT, category);
        auto existing = patCatWeight.find(key);
        if (existing == patCatWeight.end()) {
            patCatWeight[key] = weight;
        } else {
            // If there's some reason we might want max; typically it's the same weight
            // but let's do max() to emulate Python's .groupby max
            patCatWeight[key] = std::max(existing->second, weight);
        }
    }

    // Now sum across categories for each patient
    // so patient_cci_sum = sum of each category’s weight
    for (auto &kv : patCatWeight) {
        const std::string &patient = kv.first.first;
        int w = kv.second;
        charlsonScore[patient] += w;
    }
}

/****************************************************
 * 2) Compute Elixhauser
 ****************************************************/
static void computeElixhauserIndex(const std::vector<ConditionRow> &conds,
                                   std::unordered_map<std::string,double> &elixScore)
{
    // Similar approach: group by (patient, category), take max weight
    std::map<std::pair<std::string,std::string>, int> patCatWeight;

    for (auto &c : conds) {
        long long codeLL=0;
        try {
            codeLL = std::stoll(c.CODE);
        } catch(...) { continue; }
        auto it = SNOMED_TO_ELIXHAUSER.find(codeLL);
        if (it == SNOMED_TO_ELIXHAUSER.end()) {
            continue;
        }
        const std::string &category = it->second;
        auto wIt = ELIXHAUSER_CATEGORY_WEIGHTS.find(category);
        if (wIt == ELIXHAUSER_CATEGORY_WEIGHTS.end()) {
            continue;
        }
        int weight = wIt->second;

        auto key = std::make_pair(c.PATIENT, category);
        auto existing = patCatWeight.find(key);
        if (existing == patCatWeight.end()) {
            patCatWeight[key] = weight;
        } else {
            patCatWeight[key] = std::max(existing->second, weight);
        }
    }
    // sum for each patient
    for (auto &kv : patCatWeight) {
        const std::string &patient = kv.first.first;
        elixScore[patient] += kv.second;
    }
}

/****************************************************
 * Health Index logic
 ****************************************************/
struct ObsThreshold { double minVal; double maxVal; };
static std::map<std::string,ObsThreshold> OBS_THRESHOLDS = {
    {"Systolic Blood Pressure",{90,120}},
    {"Body Mass Index",{18.5,24.9}}
};
static std::map<std::string,std::string> OBS_DESC_MAP = {
    {"Systolic Blood Pressure","Systolic Blood Pressure"},
    {"Body mass index (BMI) [Ratio]","Body Mass Index"}
};

// We'll define some "groups" => codes => weights for Comorbidity_Score
static std::map<std::string,std::vector<std::string>> SNOMED_GROUPS = {
    {"Cardiovascular Diseases",{"53741008","445118002","22298006"}},
    {"Respiratory Diseases",   {"19829001","233604007"}},
    {"Diabetes",               {"44054006","73211009"}},
    {"Cancer",                 {"363346000","254637007"}}
};
static std::map<std::string,double> GROUP_WEIGHTS = {
    {"Cardiovascular Diseases",3.0},
    {"Respiratory Diseases",  2.0},
    {"Diabetes",              2.0},
    {"Cancer",                3.0},
    {"Other",                 1.0}
};

static double findGroupWeight(const std::string &codeStr) {
    // We'll do a simplistic check if code is in these groups
    for (auto &kv : SNOMED_GROUPS) {
        for (auto &c : kv.second) {
            if (c == codeStr) {
                return GROUP_WEIGHTS[kv.first];
            }
        }
    }
    return GROUP_WEIGHTS["Other"];
}
static bool isAbnormalObs(const std::string &desc, double val) {
    auto it = OBS_DESC_MAP.find(desc);
    if (it != OBS_DESC_MAP.end()) {
        // e.g. "Body Mass Index"
        auto thr = OBS_THRESHOLDS.find(it->second);
        if (thr != OBS_THRESHOLDS.end()) {
            if (val < thr->second.minVal || val > thr->second.maxVal) {
                return true;
            }
        }
    }
    return false;
}

static double computeHealthIndex(const PatientRecord &p) {
    // Same approximate formula as we used before
    double base = 10.0;
    double penalty1 = 0.4 * p.Comorbidity_Score;
    double penalty2 = 1.0 * p.Hospitalizations_Count;
    double penalty3 = 0.2 * p.Medications_Count;
    double penalty4 = 0.3 * p.Abnormal_Observations_Count;
    double penalty5 = 0.1 * p.CharlsonIndex + 0.05 * p.ElixhauserIndex;

    double raw = base - (penalty1 + penalty2 + penalty3 + penalty4 + penalty5);
    if (raw < 1) raw = 1;
    if (raw > 10) raw = 10;
    return raw;
}

/****************************************************
 * Subset Utils
 ****************************************************/
static std::set<std::string> findDiabeticPatients(const std::vector<ConditionRow> &conds) {
    std::set<std::string> out;
    for (auto &c : conds) {
        std::string lower = c.DESCRIPTION;
        for (auto &ch : lower) ch = tolower(ch);
        if (lower.find("diabetes") != std::string::npos) {
            out.insert(c.PATIENT);
        }
    }
    return out;
}
static std::set<std::string> findCKDPatients(const std::vector<ConditionRow> &conds) {
    std::set<std::string> out;
    for (auto &c : conds) {
        std::string lower = c.DESCRIPTION;
        for (auto &ch : lower) ch = tolower(ch);
        if (lower.find("chronic kidney disease") != std::string::npos ||
            lower.find("ckd") != std::string::npos) {
            out.insert(c.PATIENT);
        }
    }
    return out;
}
static std::vector<PatientRecord> filterSubpopulation(
    const std::vector<PatientRecord> &allP,
    const std::string &subsetType,
    const std::vector<ConditionRow> &conds
) {
    if (subsetType == "none") {
        return allP;
    } else if (subsetType == "diabetes") {
        auto diabs = findDiabeticPatients(conds);
        std::vector<PatientRecord> sub;
        for (auto &p : allP) {
            if (diabs.count(p.Id)) {
                sub.push_back(p);
            }
        }
        return sub;
    } else if (subsetType == "ckd") {
        auto ckdSet = findCKDPatients(conds);
        std::vector<PatientRecord> sub;
        for (auto &p : allP) {
            if (ckdSet.count(p.Id)) {
                sub.push_back(p);
            }
        }
        return sub;
    }
    return allP;
}

/****************************************************
 * Feature Utils
 ****************************************************/
static std::vector<std::string> getFeatureCols(const std::string &feature_config) {
    // Base columns
    std::vector<std::string> base = {
        "Id","GENDER","RACE","ETHNICITY","MARITAL",
        "HEALTHCARE_EXPENSES","HEALTHCARE_COVERAGE","INCOME",
        "AGE","DECEASED",
        "Hospitalizations_Count","Medications_Count","Abnormal_Observations_Count"
    };
    // Additional columns based on config
    if (feature_config == "composite") {
        base.push_back("Health_Index");
    } else if (feature_config == "cci") {
        base.push_back("CharlsonIndex");
    } else if (feature_config == "eci") {
        base.push_back("ElixhauserIndex");
    } else if (feature_config == "combined") {
        base.push_back("Health_Index");
        base.push_back("CharlsonIndex");
    } else if (feature_config == "combined_eci") {
        base.push_back("Health_Index");
        base.push_back("ElixhauserIndex");
    } else if (feature_config == "combined_all") {
        base.push_back("Health_Index");
        base.push_back("CharlsonIndex");
        base.push_back("ElixhauserIndex");
    } else {
        std::cerr << "[ERROR] invalid feature_config: " << feature_config << "\n";
    }
    return base;
}

static void writeFeaturesCSV(const std::vector<PatientRecord> &pats,
                             const std::string &outFile,
                             const std::vector<std::string> &cols)
{
    std::ofstream ofs(outFile);
    if (!ofs.is_open()) {
        std::cerr << "[ERROR] cannot open " << outFile << "\n";
        return;
    }
    // Header
    for (size_t i=0; i<cols.size(); i++) {
        ofs << cols[i];
        if (i+1<cols.size()) ofs << ",";
    }
    ofs << "\n";

    for (auto &p : pats) {
        for (size_t c=0; c<cols.size(); c++) {
            if (c>0) ofs << ",";
            const auto &col= cols[c];
            if (col=="Id") {
                ofs << p.Id;
            } else if (col=="GENDER") {
                ofs << p.GENDER;
            } else if (col=="RACE") {
                ofs << p.RACE;
            } else if (col=="ETHNICITY") {
                ofs << p.ETHNICITY;
            } else if (col=="MARITAL") {
                ofs << p.MARITAL;
            } else if (col=="HEALTHCARE_EXPENSES") {
                ofs << p.HEALTHCARE_EXPENSES;
            } else if (col=="HEALTHCARE_COVERAGE") {
                ofs << p.HEALTHCARE_COVERAGE;
            } else if (col=="INCOME") {
                ofs << p.INCOME;
            } else if (col=="AGE") {
                ofs << p.AGE;
            } else if (col=="DECEASED") {
                ofs << (p.DECEASED?"1":"0");
            } else if (col=="Hospitalizations_Count") {
                ofs << p.Hospitalizations_Count;
            } else if (col=="Medications_Count") {
                ofs << p.Medications_Count;
            } else if (col=="Abnormal_Observations_Count") {
                ofs << p.Abnormal_Observations_Count;
            } else if (col=="Health_Index") {
                ofs << p.Health_Index;
            } else if (col=="CharlsonIndex") {
                ofs << p.CharlsonIndex;
            } else if (col=="ElixhauserIndex") {
                ofs << p.ElixhauserIndex;
            } else {
                ofs << 0;
            }
        }
        ofs << "\n";
    }
    ofs.close();
    std::cout << "[INFO] Wrote features => " << outFile << "\n";
}

/****************************************************
 * Save final data akin to "patient_data_with_all_indices.pkl"
 * but in CSV form
 ****************************************************/
static void saveFinalDataCSV(const std::vector<PatientRecord> &pats,
                             const std::string &outfile)
{
    std::ofstream ofs(outfile);
    if (!ofs.is_open()) {
        std::cerr << "[ERROR] cannot open " << outfile << "\n";
        return;
    }
    ofs << "Id,BIRTHDATE,DEATHDATE,GENDER,RACE,ETHNICITY,"
        << "HEALTHCARE_EXPENSES,HEALTHCARE_COVERAGE,INCOME,MARITAL,NewData,"
        << "CharlsonIndex,ElixhauserIndex,Comorbidity_Score,"
        << "Hospitalizations_Count,Medications_Count,Abnormal_Observations_Count,"
        << "Health_Index,AGE,DECEASED\n";

    for (auto &p : pats) {
        ofs << p.Id << "," << p.BIRTHDATE << "," << p.DEATHDATE << ","
            << p.GENDER << "," << p.RACE << "," << p.ETHNICITY << ","
            << p.HEALTHCARE_EXPENSES << "," << p.HEALTHCARE_COVERAGE << ","
            << p.INCOME << "," << p.MARITAL << ","
            << (p.NewData ? "True" : "False") << ","
            << p.CharlsonIndex << "," << p.ElixhauserIndex << "," << p.Comorbidity_Score << ","
            << p.Hospitalizations_Count << "," << p.Medications_Count << "," << p.Abnormal_Observations_Count << ","
            << p.Health_Index << ","
            << p.AGE << ","
            << (p.DECEASED ? "1" : "0")
            << "\n";
    }
    ofs.close();
    std::cout << "[INFO] Wrote final data => " << outfile << "\n";
}

/****************************************************
 * Embedding Python for TabNet Inference
 ****************************************************/
static bool runPythonInference(const std::string &model_id,
                               const std::string &csvPath)
{
    // We'll assume we have "tabnet_inference.py" that:
    //   sys.argv = [script, model_id, csvPath]
    //   loads the TabNet model from Data/finals/<model_id>/<model_id>_model.zip
    //   reads <csvPath> for features
    //   writes predictions in Data/new_predictions/<model_id>/...
    // 
    std::string script = "tabnet_inference.py";

    // Build Python code
    std::ostringstream code;
    code << "import sys, runpy\n"
         << "sys.argv = ['" << script << "', '" << model_id << "', '" << csvPath << "']\n"
         << "runpy.run_path('" << script << "', run_name='__main__')\n";

    int rc = PyRun_SimpleString(code.str().c_str());
    if (rc != 0) {
        std::cerr << "[ERROR] Python inference for " << model_id
                  << " returned code " << rc << "\n";
        return false;
    }
    return true;
}

/****************************************************
 * Optional XAI
 ****************************************************/
static void runExplainability() {
    // If you have final_explain_xai_clustered_lime.py
    std::string script = "Explain_Xai/final_explain_xai_clustered_lime.py";
    FILE* fp = fopen(script.c_str(), "r");
    if (!fp) {
        std::cerr << "[WARN] can't open XAI script: " << script << "\n";
        return;
    }
    std::cout << "[INFO] Running XAI script: " << script << "\n";
    int ret = PyRun_SimpleFile(fp, script.c_str());
    fclose(fp);
    if (ret != 0) {
        std::cerr << "[ERROR] XAI script returned " << ret << "\n";
    }
}

/****************************************************
 * main()
 ****************************************************/
int main(int argc, char* argv[]) {
    int popSize = 100;
    bool enableXAI = false;

    // Parse command line
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg.rfind("--population=", 0) == 0) {
            popSize = std::stoi(arg.substr(13));
        } else if (arg == "--enable-xai") {
            enableXAI = true;
        }
    }
    std::cout << "[INFO] popSize=" << popSize
              << ", XAI=" << (enableXAI ? "true" : "false") << "\n";

    // 1) Run Synthea & copy CSV outputs
    runSynthea(popSize);
    copySyntheaOutput();

    // 2) Load entire dataset (old + new)
    std::vector<PatientRecord> allPatients;
    loadPatients(allPatients);

    std::vector<ConditionRow> conds;
    loadConditions(conds);

    std::vector<EncounterRow> encs;
    loadEncounters(encs);

    std::vector<MedicationRow> meds;
    loadMedications(meds);

    std::vector<ObservationRow> obs;
    loadObservations(obs);

    std::vector<ProcedureRow> procs;
    loadProcedures(procs);

    // 3) Compute Charlson & Elixhauser
    std::unordered_map<std::string, double> charlMap, elixMap;
    computeCharlsonIndex(conds, charlMap);
    computeElixhauserIndex(conds, elixMap);

    // 4) Additional aggregator logic
    //  (Comorbidity_Score from simpler "groups", Hospitalizations, etc.)
    // 4a) Comorbidity_Score
    std::unordered_map<std::string,double> groupScore;
    for (auto &c : conds) {
        // We'll treat c.CODE as a string
        double w = findGroupWeight(c.CODE);
        groupScore[c.PATIENT] += w;
    }
    // 4b) Hospitalizations => inpatient
    std::unordered_map<std::string,int> hospCount;
    for (auto &e : encs) {
        if (e.ENCOUNTERCLASS == "inpatient") {
            hospCount[e.PATIENT]++;
        }
    }
    // 4c) Distinct medication codes
    std::unordered_map<std::string, std::set<std::string>> medSet;
    for (auto &m : meds) {
        medSet[m.PATIENT].insert(m.CODE);
    }
    // 4d) Abnormal observations
    std::unordered_map<std::string,int> abnMap;
    for (auto &oRec : obs) {
        if (isAbnormalObs(oRec.DESCRIPTION, oRec.VALUE)) {
            abnMap[oRec.PATIENT]++;
        }
    }

    // 5) Merge into PatientRecord
    // Index them by Id
    std::unordered_map<std::string,PatientRecord*> pMap;
    for (auto &p : allPatients) {
        pMap[p.Id] = &p;
    }
    for (auto &kv : charlMap) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->CharlsonIndex = kv.second;
        }
    }
    for (auto &kv : elixMap) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->ElixhauserIndex = kv.second;
        }
    }
    for (auto &kv : groupScore) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->Comorbidity_Score = kv.second;
        }
    }
    for (auto &kv : hospCount) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->Hospitalizations_Count = kv.second;
        }
    }
    for (auto &kv : medSet) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->Medications_Count = (int)kv.second.size();
        }
    }
    for (auto &kv : abnMap) {
        if (pMap.count(kv.first)) {
            pMap[kv.first]->Abnormal_Observations_Count = kv.second;
        }
    }

    // 6) Compute Health_Index
    for (auto &p : allPatients) {
        p.Health_Index = computeHealthIndex(p);
    }

    // 7) Save final big CSV (akin to "patient_data_with_all_indices.pkl", but in CSV)
    std::string finalCSV = DATA_DIR + "/patient_data_with_all_indices.csv";
    saveFinalDataCSV(allPatients, finalCSV);

    // 8) Subset to new patients (NewData==true), run predictions for each final model
    std::vector<PatientRecord> newPatients;
    for (auto &p : allPatients) {
        if (p.NewData) {
            newPatients.push_back(p);
        }
    }
    std::cout << "[INFO] Found " << newPatients.size() << " newly generated patients.\n";
    
    // Need to set python home - causing errors I don't know why

    Py_SetPythonHome(L"C:\\Users\\imran\\miniconda3\\envs\\tf_gpu_env");

    // Initialize Python
    Py_Initialize();

    // For each final TabNet model
    for (auto &it : MODEL_CONFIG_MAP) {
        std::string model_id   = it.first;
        std::string subsetType = it.second.subset;
        std::string featconf   = it.second.feature_config;

        std::cout << "\n[INFO] Predicting with model=" << model_id
                  << ", subset=" << subsetType
                  << ", feature_config=" << featconf << "\n";

        // Filter subpopulation
        auto sub = filterSubpopulation(newPatients, subsetType, conds);
        if (sub.empty()) {
            std::cout << "[INFO] No new patients in subpop=" << subsetType
                      << " => skip.\n";
            continue;
        }
        // pick columns
        auto cols = getFeatureCols(featconf);
        // write CSV for inference
        std::string outDir = DATA_DIR + "/new_predictions/" + model_id;
        makeDirIfNeeded(DATA_DIR + "/new_predictions");
        makeDirIfNeeded(outDir);

        std::string infCSV = outDir + "/input_for_inference.csv";
        writeFeaturesCSV(sub, infCSV, cols);

        // call Python
        bool ok = runPythonInference(model_id, infCSV);
        if (!ok) {
            std::cerr << "[WARN] Inference for " << model_id << " failed.\n";
        }
    }

    // optionally run XAI
    if (enableXAI) {
        runExplainability();
    }

    // finalize Python
    Py_Finalize();

    std::cout << "[INFO] Done. Generated new data, computed Charlson/Elixhauser, "
              << "computed health index, saved final CSV, ran TabNet, XAI="
              << (enableXAI ? "true" : "false") << ".\n";
    return 0;
}

# ========================================
# File: HealthIndex.cpp
# ========================================
#include <cmath>
#include <algorithm>
#include "HealthIndex.h"
#include "DataStructures.h"

// Constants for health index calculation - aligned with Python implementation
const double AGE_WEIGHT = 0.15;
const double CHARLSON_WEIGHT = 0.25;
const double ELIXHAUSER_WEIGHT = 0.20;
const double HOSPITALIZATIONS_WEIGHT = 0.15;
const double MEDICATIONS_WEIGHT = 0.10;
const double ABNORMAL_OBS_WEIGHT = 0.15;

// Helper function to scale a value between 0-10, similar to Python's scaler
double scaleValue(double value, double min_val, double max_val) {
    // Handle edge case
    if (max_val - min_val < 0.000001) return 5.0;
    
    // Scale to 1-10 range (we subtract from 10 for factors where higher is worse)
    return 1.0 + 9.0 * (value - min_val) / (max_val - min_val);
}

// Function to compute health index similar to Python implementation
float computeHealthIndex(const PatientRecord& patient) {
    // Exactly match Python's implementation in health_index.py
    double base = 100.0;  // Python uses 100 not 10
    
    // These coefficients match Python implementation
    double penalty1 = 0.5 * patient.Comorbidity_Score;  // Python uses 0.5 not 0.4
    double penalty2 = 1.2 * patient.Hospitalizations_Count;  // Python uses 1.2 not 1.0
    double penalty3 = 0.3 * patient.Medications_Count;  // Python uses 0.3 not 0.2
    double penalty4 = 0.35 * patient.Abnormal_Observations_Count;  // Python uses 0.35 not 0.3
    double penalty5 = 0.15 * patient.CharlsonIndex + 0.08 * patient.ElixhauserIndex;  // Different coefficients
    
    double rawIndex = base - (penalty1 + penalty2 + penalty3 + penalty4 + penalty5);
    
    // Clamp and normalize as in Python
    rawIndex = std::max(0.0, std::min(rawIndex, 100.0));
    
    // Important: Python rescales to 1-10 range with min-max normalization
    // Assume MIN_HEALTH=30, MAX_HEALTH=90 as in Python
    const double MIN_HEALTH = 30.0;
    const double MAX_HEALTH = 90.0;
    double normalizedIndex = 1.0 + 9.0 * (rawIndex - MIN_HEALTH) / (MAX_HEALTH - MIN_HEALTH);
    
    // Final clamping to ensure values are in correct range
    return static_cast<float>(std::max(1.0, std::min(10.0, normalizedIndex)));
}


# ========================================
# File: HealthIndex.h
# ========================================
#pragma once

#ifndef HEALTH_INDEX_H
#define HEALTH_INDEX_H

#include "DataStructures.h"

// Function declaration only - implementation is in HealthIndex.cpp
float computeHealthIndex(const PatientRecord& patient);

#endif // HEALTH_INDEX_H


# ========================================
# File: MedicalDictionaries.cpp
# ========================================
#include "MedicalDictionaries.h"
#include <unordered_map>
#include <string>
#include <algorithm>
#include <iostream>
#include <cctype>

// Global lookup tables
std::unordered_map<std::string, float> CHARLSON_CODE_TO_WEIGHT;
std::unordered_map<std::string, float> ELIXHAUSER_CODE_TO_WEIGHT;
std::unordered_map<std::string, float> COMORBIDITY_CODE_TO_WEIGHT;

// For abnormal observation quick lookup
std::unordered_map<std::string, std::pair<double, double>> OBS_NORMAL_RANGES;

// Initialize lookup tables that match Python implementation from charlson_comorbidity.py
void initializeDirectLookups() {
    std::cout << "[INFO] Initializing Charlson lookup tables with SNOMED CT codes\n";
    
    // Charlson comorbidity SNOMED CT codes and weights - directly from charlson_comorbidity.py
    
    // MYOCARDIAL INFARCTION (weight 1)
    CHARLSON_CODE_TO_WEIGHT["22298006"] = 1.0f;    // Myocardial infarction (disorder)
    CHARLSON_CODE_TO_WEIGHT["401303003"] = 1.0f;   // Acute ST segment elevation myocardial infarction
    CHARLSON_CODE_TO_WEIGHT["401314000"] = 1.0f;   // Acute non-ST segment elevation myocardial infarction
    CHARLSON_CODE_TO_WEIGHT["129574000"] = 1.0f;   // Postoperative myocardial infarction (disorder)
    
    // CONGESTIVE HEART FAILURE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["88805009"] = 1.0f;    // Chronic congestive heart failure (disorder)
    CHARLSON_CODE_TO_WEIGHT["84114007"] = 1.0f;    // Heart failure (disorder)
    
    // CEREBROVASCULAR DISEASE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["230690007"] = 1.0f;   // Cerebrovascular accident (disorder)
    
    // DEMENTIA (weight 1)
    CHARLSON_CODE_TO_WEIGHT["26929004"] = 1.0f;    // Alzheimer's disease (disorder)
    CHARLSON_CODE_TO_WEIGHT["230265002"] = 1.0f;   // Familial Alzheimer's disease of early onset (disorder)
    
    // CHRONIC PULMONARY DISEASE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["185086009"] = 1.0f;   // Chronic obstructive bronchitis (disorder)
    CHARLSON_CODE_TO_WEIGHT["87433001"] = 1.0f;    // Pulmonary emphysema (disorder)
    CHARLSON_CODE_TO_WEIGHT["195967001"] = 1.0f;   // Asthma (disorder)
    CHARLSON_CODE_TO_WEIGHT["233678006"] = 1.0f;   // Childhood asthma (disorder)
    
    // CONNECTIVE TISSUE DISEASE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["69896004"] = 1.0f;    // Rheumatoid arthritis (disorder)
    CHARLSON_CODE_TO_WEIGHT["200936003"] = 1.0f;   // Lupus erythematosus (disorder)
    
    // MILD LIVER DISEASE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["128302006"] = 1.0f;   // Chronic hepatitis C (disorder)
    CHARLSON_CODE_TO_WEIGHT["61977001"] = 1.0f;    // Chronic type B viral hepatitis (disorder)
    
    // DIABETES WITHOUT END-ORGAN DAMAGE (weight 1)
    CHARLSON_CODE_TO_WEIGHT["44054006"] = 1.0f;    // Diabetes mellitus type 2 (disorder)
    
    // DIABETES WITH END-ORGAN DAMAGE (weight 2)
    CHARLSON_CODE_TO_WEIGHT["368581000119106"] = 2.0f;  // Neuropathy due to type 2 diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["422034002"] = 2.0f;        // Retinopathy due to type 2 diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["127013003"] = 2.0f;        // Disorder of kidney due to diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["90781000119102"] = 2.0f;   // Microalbuminuria due to type 2 diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["157141000119108"] = 2.0f;  // Proteinuria due to type 2 diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["60951000119105"] = 2.0f;   // Blindness due to type 2 diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["97331000119101"] = 2.0f;   // Macular edema & retinopathy due to T2DM
    CHARLSON_CODE_TO_WEIGHT["1501000119109"] = 2.0f;    // Proliferative retinopathy due to T2DM
    CHARLSON_CODE_TO_WEIGHT["1551000119108"] = 2.0f;    // Nonproliferative retinopathy due to T2DM
    
    // MODERATE OR SEVERE KIDNEY DISEASE (weight 2)
    CHARLSON_CODE_TO_WEIGHT["431855005"] = 2.0f;        // CKD stage 1 (disorder)
    CHARLSON_CODE_TO_WEIGHT["431856006"] = 2.0f;        // CKD stage 2 (disorder)
    CHARLSON_CODE_TO_WEIGHT["433144002"] = 2.0f;        // CKD stage 3 (disorder)
    CHARLSON_CODE_TO_WEIGHT["431857002"] = 2.0f;        // CKD stage 4 (disorder)
    CHARLSON_CODE_TO_WEIGHT["46177005"] = 2.0f;         // End-stage renal disease (disorder)
    CHARLSON_CODE_TO_WEIGHT["129721000119106"] = 2.0f;  // Acute renal failure on dialysis (disorder)
    
    // ANY TUMOUR (solid tumor), LEUKEMIA, LYMPHOMA (weight 2)
    CHARLSON_CODE_TO_WEIGHT["254637007"] = 2.0f;   // Non-small cell lung cancer (disorder)
    CHARLSON_CODE_TO_WEIGHT["254632001"] = 2.0f;   // Small cell carcinoma of lung (disorder)
    CHARLSON_CODE_TO_WEIGHT["93761005"] = 2.0f;    // Primary malignant neoplasm of colon
    CHARLSON_CODE_TO_WEIGHT["363406005"] = 2.0f;   // Malignant neoplasm of colon
    CHARLSON_CODE_TO_WEIGHT["109838007"] = 2.0f;   // Overlapping malignant neoplasm of colon
    CHARLSON_CODE_TO_WEIGHT["126906006"] = 2.0f;   // Neoplasm of prostate (disorder)
    CHARLSON_CODE_TO_WEIGHT["92691004"] = 2.0f;    // Carcinoma in situ of prostate
    CHARLSON_CODE_TO_WEIGHT["254837009"] = 2.0f;   // Malignant neoplasm of breast
    CHARLSON_CODE_TO_WEIGHT["109989006"] = 2.0f;   // Multiple myeloma (disorder)
    CHARLSON_CODE_TO_WEIGHT["93143009"] = 2.0f;    // Leukemia disease (disorder)
    CHARLSON_CODE_TO_WEIGHT["91861009"] = 2.0f;    // Acute myeloid leukemia (disorder)
    
    // METASTATIC SOLID TUMOUR (weight 6)
    CHARLSON_CODE_TO_WEIGHT["94503003"] = 6.0f;    // Metastatic malignant neoplasm to prostate
    CHARLSON_CODE_TO_WEIGHT["94260004"] = 6.0f;    // Metastatic malignant neoplasm to colon
    
    // AIDS/HIV (weight 6)
    CHARLSON_CODE_TO_WEIGHT["62479008"] = 6.0f;   // Acquired immune deficiency syndrome (disorder)
    CHARLSON_CODE_TO_WEIGHT["86406008"] = 6.0f;   // Human immunodeficiency virus infection (disorder)

    // Add string versions of common diabetes and CKD codes for subset identification
    // (no need to convert all numeric codes to strings since the lookup will handle it)
    CHARLSON_CODE_TO_WEIGHT["73211009"] = 1.0f;   // Diabetes mellitus
    CHARLSON_CODE_TO_WEIGHT["46635009"] = 1.0f;   // Diabetes mellitus type 1
    CHARLSON_CODE_TO_WEIGHT["190330002"] = 1.0f;  // Type 2 diabetes mellitus

    std::cout << "[INFO] Added " << CHARLSON_CODE_TO_WEIGHT.size() << " SNOMED CT codes to Charlson dictionary\n";
}

void initializeElixhauserLookups() {
    std::cout << "[INFO] Initializing Elixhauser lookup tables with SNOMED CT codes\n";
    
    // Elixhauser comorbidity codes and weights - directly from elixhauser_comorbidity.py

    // Congestive Heart Failure (weight 7)
    ELIXHAUSER_CODE_TO_WEIGHT["88805009"] = 7.0f;   // Chronic congestive heart failure
    ELIXHAUSER_CODE_TO_WEIGHT["84114007"] = 7.0f;   // Heart failure

    // Cardiac Arrhythmias (weight 5)
    ELIXHAUSER_CODE_TO_WEIGHT["49436004"] = 5.0f;   // Cardiac arrhythmias

    // Valvular Disease (weight 4)
    ELIXHAUSER_CODE_TO_WEIGHT["48724000"] = 4.0f;   // Valvular disease
    ELIXHAUSER_CODE_TO_WEIGHT["91434003"] = 4.0f;   // Pulmonic valve regurgitation
    ELIXHAUSER_CODE_TO_WEIGHT["79619009"] = 4.0f;   // Mitral valve stenosis
    ELIXHAUSER_CODE_TO_WEIGHT["111287006"] = 4.0f;  // Tricuspid valve regurgitation
    ELIXHAUSER_CODE_TO_WEIGHT["49915006"] = 4.0f;   // Tricuspid valve stenosis
    ELIXHAUSER_CODE_TO_WEIGHT["60573004"] = 4.0f;   // Aortic valve stenosis
    ELIXHAUSER_CODE_TO_WEIGHT["60234000"] = 4.0f;   // Aortic valve regurgitation

    // Pulmonary Circulation Disorders (weight 6)
    ELIXHAUSER_CODE_TO_WEIGHT["65710008"] = 6.0f;   // Pulmonary circulation disorders
    ELIXHAUSER_CODE_TO_WEIGHT["706870000"] = 6.0f;  // Acute pulmonary embolism
    ELIXHAUSER_CODE_TO_WEIGHT["67782005"] = 6.0f;   // Acute respiratory distress syndrome

    // Peripheral Vascular Disorders (weight 2)
    ELIXHAUSER_CODE_TO_WEIGHT["698754002"] = 2.0f;  // Peripheral vascular disorders

    // Hypertension, uncomplicated (weight -1)
    ELIXHAUSER_CODE_TO_WEIGHT["59621000"] = -1.0f;  // Hypertension, uncomplicated

    // Paralysis (weight 7)
    ELIXHAUSER_CODE_TO_WEIGHT["698754002"] = 7.0f;  // Paralysis (note: duplicate with peripheral vascular disorders)
    ELIXHAUSER_CODE_TO_WEIGHT["128188000"] = 7.0f;  // Paralysis

    // Other Neurological Disorders (weight 6)
    ELIXHAUSER_CODE_TO_WEIGHT["69896004"] = 6.0f;   // Other neurological disorders
    ELIXHAUSER_CODE_TO_WEIGHT["128613002"] = 6.0f;  // Seizure disorder

    // Chronic Pulmonary Disease (weight 3)
    ELIXHAUSER_CODE_TO_WEIGHT["195967001"] = 3.0f;  // Chronic pulmonary disease
    ELIXHAUSER_CODE_TO_WEIGHT["233678006"] = 3.0f;  // Chronic pulmonary disease

    // Diabetes, Complicated (weight 7)
    ELIXHAUSER_CODE_TO_WEIGHT["368581000119106"] = 7.0f;  // Diabetes, complicated
    ELIXHAUSER_CODE_TO_WEIGHT["422034002"] = 7.0f;        // Diabetes, complicated
    ELIXHAUSER_CODE_TO_WEIGHT["90781000119102"] = 7.0f;   // Diabetes, complicated

    // Diabetes, Uncomplicated (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["44054006"] = 0.0f;   // Diabetes, uncomplicated

    // Renal Failure (weight 5)
    ELIXHAUSER_CODE_TO_WEIGHT["129721000119106"] = 5.0f;  // Renal failure
    ELIXHAUSER_CODE_TO_WEIGHT["433144002"] = 5.0f;        // Renal failure

    // Liver Disease (weight 11)
    ELIXHAUSER_CODE_TO_WEIGHT["128302006"] = 11.0f;  // Liver disease
    ELIXHAUSER_CODE_TO_WEIGHT["61977001"] = 11.0f;   // Liver disease

    // AIDS/HIV (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["62479008"] = 0.0f;   // AIDS/HIV
    ELIXHAUSER_CODE_TO_WEIGHT["86406008"] = 0.0f;   // AIDS/HIV

    // Lymphoma (weight 9)
    ELIXHAUSER_CODE_TO_WEIGHT["93143009"] = 9.0f;   // Lymphoma

    // Metastatic Cancer (weight 14)
    ELIXHAUSER_CODE_TO_WEIGHT["94503003"] = 14.0f;  // Metastatic cancer
    ELIXHAUSER_CODE_TO_WEIGHT["94260004"] = 14.0f;  // Metastatic cancer

    // Solid Tumour Without Metastasis (weight 8)
    ELIXHAUSER_CODE_TO_WEIGHT["126906006"] = 8.0f;  // Solid tumour without metastasis
    ELIXHAUSER_CODE_TO_WEIGHT["254637007"] = 8.0f;  // Solid tumour without metastasis

    // Rheumatoid Arthritis / Collagen Vascular Diseases (weight 4)
    ELIXHAUSER_CODE_TO_WEIGHT["69896004"] = 4.0f;    // Rheumatoid arthritis/collagen vascular diseases
    ELIXHAUSER_CODE_TO_WEIGHT["200936003"] = 4.0f;   // Rheumatoid arthritis/collagen vascular diseases

    // Coagulopathy (weight 11)
    ELIXHAUSER_CODE_TO_WEIGHT["234466008"] = 11.0f;  // Coagulopathy

    // Obesity (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["408512008"] = 0.0f;  // Obesity
    ELIXHAUSER_CODE_TO_WEIGHT["162864005"] = 0.0f;  // Obesity

    // Weight Loss (weight 6)
    ELIXHAUSER_CODE_TO_WEIGHT["278860009"] = 6.0f;  // Weight loss

    // Fluid and Electrolyte Disorders (weight 5)
    ELIXHAUSER_CODE_TO_WEIGHT["389087006"] = 5.0f;  // Fluid and electrolyte disorders

    // Deficiency Anaemias (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["271737000"] = 0.0f;  // Deficiency anaemias

    // Alcohol Abuse (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["7200002"] = 0.0f;    // Alcohol abuse

    // Drug Abuse (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["6525002"] = 0.0f;    // Drug abuse

    // Psychoses (weight 0)
    ELIXHAUSER_CODE_TO_WEIGHT["47505003"] = 0.0f;   // Psychoses

    // Depression (weight -3)
    ELIXHAUSER_CODE_TO_WEIGHT["370143000"] = -3.0f;  // Depression
    ELIXHAUSER_CODE_TO_WEIGHT["36923009"] = -3.0f;   // Depression

    // Add additional codes for CKD and diabetes used in subset identification
    ELIXHAUSER_CODE_TO_WEIGHT["431855005"] = 5.0f;  // Chronic kidney disease
    ELIXHAUSER_CODE_TO_WEIGHT["431856006"] = 5.0f;  // Chronic kidney disease stage 1
    ELIXHAUSER_CODE_TO_WEIGHT["433144002"] = 5.0f;  // Chronic kidney disease stage 2
    ELIXHAUSER_CODE_TO_WEIGHT["431857002"] = 5.0f;  // Chronic kidney disease stage 3
    ELIXHAUSER_CODE_TO_WEIGHT["46177005"] = 5.0f;   // End stage renal disease
    
    ELIXHAUSER_CODE_TO_WEIGHT["73211009"] = 0.5f;   // Diabetes mellitus
    ELIXHAUSER_CODE_TO_WEIGHT["46635009"] = 0.5f;   // Diabetes mellitus type 1
    ELIXHAUSER_CODE_TO_WEIGHT["190330002"] = 0.5f;  // Type 2 diabetes mellitus

    std::cout << "[INFO] Added " << ELIXHAUSER_CODE_TO_WEIGHT.size() << " SNOMED CT codes to Elixhauser dictionary\n";
}

void initializeObsAbnormalDirect() {
    std::cout << "[INFO] Initializing observation normal range lookup\n";
    
    // Normal ranges for common observations - these match health_index.py
    OBS_NORMAL_RANGES = {
        {"Systolic Blood Pressure", {90.0, 120.0}},
        {"Diastolic Blood Pressure", {60.0, 80.0}},
        {"Body Mass Index", {18.5, 24.9}},
        {"Blood Glucose Level", {70.0, 99.0}},
        {"Heart Rate", {60.0, 100.0}}
    };
}

// Helper function to check if observation value is abnormal
bool isAbnormalObsFast(const std::string &obsDescription, double value) {
    // Fast path using direct lookup table
    auto it = OBS_NORMAL_RANGES.find(obsDescription);
    if (it != OBS_NORMAL_RANGES.end()) {
        auto [min_val, max_val] = it->second;
        return value < min_val || value > max_val;
    }
    
    // Try alternate common descriptions
    if (obsDescription.find("systolic") != std::string::npos || 
        obsDescription.find("SYSTOLIC") != std::string::npos) {
        return value < 90.0 || value > 120.0;
    }
    
    if (obsDescription.find("diastolic") != std::string::npos || 
        obsDescription.find("DIASTOLIC") != std::string::npos) {
        return value < 60.0 || value > 80.0;
    }
    
    if (obsDescription.find("BMI") != std::string::npos || 
        obsDescription.find("body mass index") != std::string::npos) {
        return value < 18.5 || value > 24.9;
    }
    
    if (obsDescription.find("glucose") != std::string::npos || 
        obsDescription.find("GLUCOSE") != std::string::npos) {
        return value < 70.0 || value > 99.0;
    }
    
    if (obsDescription.find("heart rate") != std::string::npos || 
        obsDescription.find("HEART RATE") != std::string::npos) {
        return value < 60.0 || value > 100.0;
    }
    
    // For unrecognized observations, fall back to domain-specific thresholds
    if (value > 500.0) return true; // Large values are usually abnormal
    
    return false;  // Don't mark as abnormal if we don't recognize it
}


# ========================================
# File: MedicalDictionaries.h
# ========================================
#pragma once

#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <iostream>
#include <algorithm>

// Define ObsThreshold struct in global namespace
struct ObsThreshold { 
    double minVal; 
    double maxVal; 
};

// External declarations for dictionaries - they are defined in the .cpp file
extern std::unordered_map<std::string, float> CHARLSON_CODE_TO_WEIGHT;
extern std::unordered_map<std::string, float> ELIXHAUSER_CODE_TO_WEIGHT;
extern std::unordered_map<std::string, std::pair<double, double>> OBS_ABNORMAL_THRESHOLDS;

// Function declarations
void initializeDirectLookups();
void initializeElixhauserLookups();
void initializeObsAbnormalDirect();

// Helper functions
bool isAbnormalObsFast(const std::string& description, double value);
double findGroupWeightFast(const std::string& code);

// Namespace for reference dictionaries that won't be directly modified
namespace medical_constants {
    // CHARLSON INDEX DICTIONARIES
    static const std::map<long long, std::string> SNOMED_TO_CHARLSON = {
        // MYOCARDIAL INFARCTION (weight 1)
        {22298006, "Myocardial infarction"},
        {401303003, "Myocardial infarction"},
        {401314000, "Myocardial infarction"},
        {129574000, "Myocardial infarction"},
        
        // CONGESTIVE HEART FAILURE (weight 1)
        {88805009,  "Congestive heart failure"},
        {84114007,  "Congestive heart failure"},

        // PERIPHERAL VASCULAR DISEASE (weight 1)
        // (No explicit codes in that snippet, so omitted)

        // CEREBROVASCULAR DISEASE (weight 1)
        {230690007, "Cerebrovascular disease"},

        // DEMENTIA (weight 1)
        {26929004,  "Dementia"},
        {230265002, "Dementia"},

        // CHRONIC PULMONARY DISEASE (weight 1)
        {185086009, "Chronic pulmonary disease"},
        {87433001,  "Chronic pulmonary disease"},
        {195967001, "Chronic pulmonary disease"},
        {233678006, "Chronic pulmonary disease"},

        // CONNECTIVE TISSUE DISEASE (weight 1)
        {69896004,  "Connective tissue disease"},
        {200936003, "Connective tissue disease"},

        // ULCER DISEASE (weight 1)
        // (No explicit codes in that snippet)

        // MILD LIVER DISEASE (weight 1)
        {128302006, "Mild liver disease"},
        {61977001,  "Mild liver disease"},

        // DIABETES WITHOUT END-ORGAN DAMAGE (weight 1)
        {44054006,  "Diabetes without end-organ damage"},

        // DIABETES WITH END-ORGAN DAMAGE (weight 2)
        {368581000119106LL, "Diabetes with end-organ damage"},
        {422034002,         "Diabetes with end-organ damage"},
        {127013003,         "Diabetes with end-organ damage"},
        {90781000119102LL,  "Diabetes with end-organ damage"},
        {157141000119108LL, "Diabetes with end-organ damage"},
        {60951000119105LL,  "Diabetes with end-organ damage"},
        {97331000119101LL,  "Diabetes with end-organ damage"},
        {1501000119109LL,   "Diabetes with end-organ damage"},
        {1551000119108LL,   "Diabetes with end-organ damage"},

        // HEMIPLEGIA/PARAPLEGIA (weight 2)
        // (No explicit codes in that snippet)

        // MODERATE OR SEVERE KIDNEY DISEASE (weight 2)
        {431855005, "Moderate or severe kidney disease"},
        {431856006, "Moderate or severe kidney disease"},
        {433144002, "Moderate or severe kidney disease"},
        {431857002, "Moderate or severe kidney disease"},
        {46177005,  "Moderate or severe kidney disease"},
        {129721000119106LL, "Moderate or severe kidney disease"},

        // ANY TUMOUR (weight 2)
        {254637007, "Any tumour, leukaemia, lymphoma"},
        {254632001, "Any tumour, leukaemia, lymphoma"},
        {93761005,  "Any tumour, leukaemia, lymphoma"},
        {363406005, "Any tumour, leukaemia, lymphoma"},
        {109838007, "Any tumour, leukaemia, lymphoma"},
        {126906006, "Any tumour, leukaemia, lymphoma"},
        {92691004,  "Any tumour, leukaemia, lymphoma"},
        {254837009, "Any tumour, leukaemia, lymphoma"},
        {109989006, "Any tumour, leukaemia, lymphoma"},
        {93143009,  "Any tumour, leukaemia, lymphoma"},
        {91861009,  "Any tumour, leukaemia, lymphoma"},

        // METASTATIC SOLID TUMOUR (weight 6)
        {94503003,  "Metastatic solid tumour"},
        {94260004,  "Metastatic solid tumour"},

        // AIDS/HIV (weight 6)
        {62479008,  "AIDS/HIV"},
        {86406008,  "AIDS/HIV"}
    };

    // Category->CharlsonWeight
    static const std::map<std::string,int> CHARLSON_CATEGORY_WEIGHTS = {
        {"Myocardial infarction", 1},
        {"Congestive heart failure", 1},
        {"Peripheral vascular disease", 1},
        {"Cerebrovascular disease", 1},
        {"Dementia", 1},
        {"Chronic pulmonary disease", 1},
        {"Connective tissue disease", 1},
        {"Ulcer disease", 1},
        {"Mild liver disease", 1},
        {"Diabetes without end-organ damage", 1},

        {"Hemiplegia", 2},
        {"Moderate or severe kidney disease", 2},
        {"Diabetes with end-organ damage", 2},
        {"Any tumour, leukaemia, lymphoma", 2},

        {"Moderate or severe liver disease", 3},
        {"Metastatic solid tumour", 6},
        {"AIDS/HIV", 6}
    };

    // ELIXHAUSER INDEX DICTIONARIES
    static const std::map<long long, std::string> SNOMED_TO_ELIXHAUSER = {
       // Congestive Heart Failure
       {88805009,  "Congestive heart failure"},
       {84114007,  "Congestive heart failure"},

       // Cardiac Arrhythmias
       {49436004,  "Cardiac arrhythmias"},

       // Valvular Disease
       {48724000,  "Valvular disease"},
       {91434003,  "Pulmonic valve regurgitation"},
       {79619009,  "Mitral valve stenosis"},
       {111287006, "Tricuspid valve regurgitation"},
       {49915006,  "Tricuspid valve stenosis"},
       {60573004,  "Aortic valve stenosis"},
       {60234000,  "Aortic valve regurgitation"},

       // Pulmonary Circulation Disorders
       {65710008,  "Pulmonary circulation disorders"},
       {706870000, "Acute pulmonary embolism"},
       {67782005,  "Acute respiratory distress syndrome"},

       // Peripheral Vascular Disorders
       {698754002, "Peripheral vascular disorders"},

       // Hypertension
       {59621000,  "Hypertension, uncomplicated"},

       // Paralysis
       // Overwrites the earlier "Peripheral vascular disorders" for 698754002
       {698754002, "Paralysis"},
       {128188000, "Paralysis"},

       // Other Neurological Disorders
       {69896004,  "Other neurological disorders"},
       {128613002, "Seizure disorder"},

       // Chronic Pulmonary Disease
       {195967001, "Chronic pulmonary disease"},
       {233678006, "Chronic pulmonary disease"},

       // Diabetes, Complicated
       {368581000119106, "Diabetes, complicated"},
       {422034002,        "Diabetes, complicated"},
       {90781000119102,   "Diabetes, complicated"},

       // Diabetes, Uncomplicated
       {44054006,  "Diabetes, uncomplicated"},

       // Renal Failure
       {129721000119106, "Renal failure"},
       {433144002,       "Renal failure"},

       // Liver Disease
       {128302006, "Liver disease"},
       {61977001,  "Liver disease"},

       // AIDS/HIV
       {62479008,  "AIDS/HIV"},
       {86406008,  "AIDS/HIV"},

       // Lymphoma
       {93143009,  "Lymphoma"},

       // Metastatic Cancer
       {94503003,  "Metastatic cancer"},
       {94260004,  "Metastatic cancer"},

       // Solid Tumour Without Metastasis
       {126906006, "Solid tumour without metastasis"},
       {254637007, "Solid tumour without metastasis"},

       // Rheumatoid Arthritis / Collagen Vascular Diseases
       {69896004,  "Rheumatoid arthritis/collagen vascular diseases"},
       {200936003, "Rheumatoid arthritis/collagen vascular diseases"},

       // Coagulopathy
       {234466008, "Coagulopathy"},

       // Obesity
       {408512008, "Obesity"},
       {162864005, "Obesity"},

       // Weight Loss
       {278860009, "Weight loss"},

       // Fluid and Electrolyte Disorders
       {389087006, "Fluid and electrolyte disorders"},

       // Deficiency Anaemias
       {271737000, "Deficiency anaemias"},

       // Alcohol Abuse
       {7200002,   "Alcohol abuse"},

       // Drug Abuse
       {6525002,   "Drug abuse"},

       // Psychoses
       {47505003,  "Psychoses"},

       // Depression
       {370143000, "Depression"},
       {36923009,  "Depression"}
    };

    // van Walraven weighting
    static const std::map<std::string,int> ELIXHAUSER_CATEGORY_WEIGHTS = {
       {"Congestive heart failure", 7},
       {"Cardiac arrhythmias", 5},
       {"Valvular disease", 4},
       {"Pulmonary circulation disorders", 6},
       {"Peripheral vascular disorders", 2},
       {"Hypertension, uncomplicated", -1},
       {"Hypertension, complicated", 0},
       {"Paralysis", 7},
       {"Other neurological disorders", 6},
       {"Chronic pulmonary disease", 3},
       {"Diabetes, uncomplicated", 0},
       {"Diabetes, complicated", 7},
       {"Hypothyroidism", 0},
       {"Renal failure", 5},
       {"Liver disease", 11},
       {"Peptic ulcer disease", 0},
       {"AIDS/HIV", 0},
       {"Lymphoma", 9},
       {"Metastatic cancer", 14},
       {"Solid tumour without metastasis", 8},
       {"Rheumatoid arthritis/collagen vascular diseases", 4},
       {"Coagulopathy", 11},
       {"Obesity", 0},
       {"Weight loss", 6},
       {"Fluid and electrolyte disorders", 5},
       {"Blood loss anaemia", 3},
       {"Deficiency anaemias", 0},
       {"Alcohol abuse", 0},
       {"Drug abuse", 0},
       {"Psychoses", 0},
       {"Depression", -3}
    };

    // GROUP-BASED COMORBIDITY
    static const std::map<std::string,std::vector<std::string>> SNOMED_GROUPS = {
        {"Cardiovascular Diseases",{"53741008","445118002","22298006"}},
        {"Respiratory Diseases",   {"19829001","233604007"}},
        {"Diabetes",               {"44054006","73211009"}},
        {"Cancer",                 {"363346000","254637007"}}
    };

    static const std::map<std::string,double> GROUP_WEIGHTS = {
        {"Cardiovascular Diseases",3.0},
        {"Respiratory Diseases",  2.0},
        {"Diabetes",              2.0},
        {"Cancer",                3.0},
        {"Other",                 1.0}
    };

    // OBSERVATIONS
    static const std::map<std::string, ObsThreshold> OBS_THRESHOLDS = {
        {"Systolic Blood Pressure",{90,120}},
        {"Body Mass Index",{18.5,24.9}}
    };

    static const std::map<std::string,std::string> OBS_DESC_MAP = {
        {"Systolic Blood Pressure","Systolic Blood Pressure"},
        {"Body mass index (BMI) [Ratio]","Body Mass Index"}
    };
} // namespace medical_constants


# ========================================
# File: PatientSubsets.cpp
# ========================================
#include "PatientSubsets.h"
#include <algorithm>
#include <mutex>
#include <thread>
#include <iostream>
#include "DataStructures.h"
#include <string>
#include <set>
#include <vector>

std::unordered_set<std::string> findDiabeticPatientsOptimized(const std::vector<ConditionRow> &conds) {
    std::unordered_set<std::string> out;
    out.reserve(conds.size() / 10); // Pre-allocate with estimate of diabetic patients
    
    // Simple implementation for now
    for (const auto& c : conds) {
        std::string lower = c.DESCRIPTION;
        std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
        
        if (lower.find("diabetes") != std::string::npos || 
            lower.find("diabetic") != std::string::npos) {
            out.insert(c.PATIENT);
        }
    }
    
    return out;
}

std::unordered_set<std::string> findCKDPatientsOptimized(const std::vector<ConditionRow> &conds) {
    std::unordered_set<std::string> out;
    out.reserve(conds.size() / 10); // Pre-allocate with estimate of CKD patients
    
    // Simple implementation for now
    for (const auto& c : conds) {
        std::string lower = c.DESCRIPTION;
        std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
        
        if (lower.find("chronic kidney disease") != std::string::npos ||
            lower.find("ckd") != std::string::npos ||
            lower.find("renal failure") != std::string::npos) {
            out.insert(c.PATIENT);
        }
    }
    
    return out;
}

std::unordered_set<std::string> findPatientSubsetUnordered(const std::string& subsetType, 
                                                const std::vector<ConditionRow> &conds) {
    if (subsetType == "none") {
        return std::unordered_set<std::string>();
    }
    
    if (subsetType == "diabetes") {
        return findDiabeticPatientsOptimized(conds);
    }
    
    if (subsetType == "ckd") {
        return findCKDPatientsOptimized(conds);
    }
    
    std::cerr << "[ERROR] Unknown patient subset type: " << subsetType << std::endl;
    return std::unordered_set<std::string>();
}

std::set<std::string> findPatientSubset(const std::string& condition, const std::vector<ConditionRow>& conditions) {
    std::set<std::string> patientSet;
    std::string lowerCondition = condition;
    
    // Convert condition to lowercase for case-insensitive matching
    std::transform(lowerCondition.begin(), lowerCondition.end(), lowerCondition.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    
    std::cout << "[INFO] Finding patients with condition related to: " << condition << std::endl;
    
    for (const auto& cond : conditions) {
        std::string description = cond.DESCRIPTION;
        std::transform(description.begin(), description.end(), description.begin(),
                      [](unsigned char c) { return std::tolower(c); });
        
        if (description.find(lowerCondition) != std::string::npos) {
            patientSet.insert(cond.PATIENT);
        }
    }
    
    std::cout << "[INFO] Found " << patientSet.size() << " patients with " << condition << "." << std::endl;
    return patientSet;
}


# ========================================
# File: PatientSubsets.h
# ========================================
#pragma once

#include <string>
#include <set>  // Not unordered_set
#include <vector>
#include "DataStructures.h"
#include "Utilities.h"

// Patient subset selection functions
std::unordered_set<std::string> findDiabeticPatientsOptimized(const std::vector<ConditionRow> &conds);
std::unordered_set<std::string> findCKDPatientsOptimized(const std::vector<ConditionRow> &conds);
std::set<std::string> findPatientSubset(const std::string& condition, 
                                       const std::vector<ConditionRow>& conditions);


# ========================================
# File: ResourceMonitor.cpp
# ========================================
#include "ResourceMonitor.h"
#include "SystemResources.h"
#include <iostream>
#include <thread>

void ResourceMonitor::initialize() {
    std::cout << "[INFO] Initializing resource monitor" << std::endl;
}

double ResourceMonitor::getMemoryUsageMB() {
    return SystemResources::getSystemMemoryUsageMB();
}

double ResourceMonitor::getCpuUsagePercent() {
    return SystemResources::getSystemCpuUsage();
}

void ResourceMonitor::printResourceUsage(const std::string& tag) {
    std::cout << "[RESOURCE] " << tag 
              << " Memory: " << getMemoryUsageMB() << " MB, "
              << "CPU: " << getCpuUsagePercent() << "%" << std::endl;
}


# ========================================
# File: ResourceMonitor.h
# ========================================
#pragma once

#ifndef RESOURCE_MONITOR_H
#define RESOURCE_MONITOR_H

#include <string>

class ResourceMonitor {
public:
    static void initialize();
    static double getMemoryUsageMB();
    static double getCpuUsagePercent();
    static void printResourceUsage(const std::string& tag);
};

#endif // RESOURCE_MONITOR_H


# ========================================
# File: run_debug.cpp
# ========================================
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <filesystem>
#include "DataStructures.h"
#include "FileProcessing.h"
#include "MedicalDictionaries.h"
#include "HealthIndex.h"

namespace fs = std::filesystem;

// Test function to validate the medical dictionaries
void testMedicalDictionaries() {
    std::cout << "===== Testing Medical Dictionaries =====\n";
    
    // Initialize dictionaries
    initializeDirectLookups();
    initializeElixhauserLookups();
    initializeObsAbnormalDirect();
    
    // Test common codes for diabetes
    std::vector<std::string> diabetesCodes = {
        "E11.9", "E10", "E11", "44054006", "73211009", "46635009", "diabetes"
    };
    
    std::cout << "\nTesting diabetes codes in Charlson dictionary:\n";
    for (const auto& code : diabetesCodes) {
        auto it = CHARLSON_CODE_TO_WEIGHT.find(code);
        if (it != CHARLSON_CODE_TO_WEIGHT.end()) {
            std::cout << "  FOUND: " << code << " -> " << it->second << "\n";
        } else {
            std::cout << "  NOT FOUND: " << code << "\n";
        }
    }
    
    std::cout << "\nTesting diabetes codes in Elixhauser dictionary:\n";
    for (const auto& code : diabetesCodes) {
        auto it = ELIXHAUSER_CODE_TO_WEIGHT.find(code);
        if (it != ELIXHAUSER_CODE_TO_WEIGHT.end()) {
            std::cout << "  FOUND: " << code << " -> " << it->second << "\n";
        } else {
            std::cout << "  NOT FOUND: " << code << "\n";
        }
    }
    
    // Test common observation descriptions
    std::vector<std::string> obsDescs = {
        "Systolic Blood Pressure", "Diastolic Blood Pressure", 
        "Heart Rate", "Body Mass Index", "Glucose"
    };
    
    std::cout << "\nTesting observation thresholds:\n";
    for (const auto& desc : obsDescs) {
        auto it = OBS_ABNORMAL_THRESHOLDS.find(desc);
        if (it != OBS_ABNORMAL_THRESHOLDS.end()) {
            std::cout << "  FOUND: " << desc << " -> [" << it->second.first 
                      << ", " << it->second.second << "]\n";
        } else {
            std::cout << "  NOT FOUND: " << desc << "\n";
        }
    }
}

// Test function to process a condition file and show matching rates
void testConditionMatching(const std::string& conditionFile) {
    if (!fs::exists(conditionFile)) {
        std::cerr << "Condition file not found: " << conditionFile << "\n";
        return;
    }
    
    std::cout << "\n===== Testing Condition Code Matching with " << conditionFile << " =====\n";
    
    int totalConditions = 0;
    int matchedCharlson = 0;
    int matchedElixhauser = 0;
    int matchedDescription = 0;
    
    ThreadSafeCounter charlsonCounter;
    ThreadSafeCounter elixhauserCounter;
    
    processConditionsInBatches(conditionFile, [&](const ConditionRow &cRow) {
        totalConditions++;
        
        // Try exact code match for Charlson
        auto charlsonIt = CHARLSON_CODE_TO_WEIGHT.find(cRow.CODE);
        if (charlsonIt != CHARLSON_CODE_TO_WEIGHT.end()) {
            matchedCharlson++;
            charlsonCounter.addFloat(cRow.PATIENT, charlsonIt->second);
        }
        
        // Try exact code match for Elixhauser
        auto elixhauserIt = ELIXHAUSER_CODE_TO_WEIGHT.find(cRow.CODE);
        if (elixhauserIt != ELIXHAUSER_CODE_TO_WEIGHT.end()) {
            matchedElixhauser++;
            elixhauserCounter.addFloat(cRow.PATIENT, elixhauserIt->second);
        }
        
        // Try description-based matching
        std::string lowerDesc = cRow.DESCRIPTION;
        std::transform(lowerDesc.begin(), lowerDesc.end(), lowerDesc.begin(),
                       [](unsigned char c){ return std::tolower(c); });
        
        if (lowerDesc.find("diabetes") != std::string::npos) {
            matchedDescription++;
            charlsonCounter.addFloat(cRow.PATIENT, 2.0f);
            elixhauserCounter.addFloat(cRow.PATIENT, 0.5f);
        }
        else if (lowerDesc.find("heart failure") != std::string::npos) {
            matchedDescription++;
            charlsonCounter.addFloat(cRow.PATIENT, 3.0f);
            elixhauserCounter.addFloat(cRow.PATIENT, 1.5f);
        }
        else if (lowerDesc.find("copd") != std::string::npos ||
                 lowerDesc.find("chronic obstructive pulmonary") != std::string::npos) {
            matchedDescription++;
            charlsonCounter.addFloat(cRow.PATIENT, 2.0f);
            elixhauserCounter.addFloat(cRow.PATIENT, 0.9f);
        }
    });
    
    // Print matching statistics
    std::cout << "Total conditions processed: " << totalConditions << "\n";
    std::cout << "Matched Charlson codes: " << matchedCharlson 
              << " (" << (totalConditions > 0 ? (matchedCharlson * 100.0 / totalConditions) : 0) << "%)\n";
    std::cout << "Matched Elixhauser codes: " << matchedElixhauser 
              << " (" << (totalConditions > 0 ? (matchedElixhauser * 100.0 / totalConditions) : 0) << "%)\n";
    std::cout << "Matched by description: " << matchedDescription 
              << " (" << (totalConditions > 0 ? (matchedDescription * 100.0 / totalConditions) : 0) << "%)\n";
    
    // Show some patient scores
    std::cout << "\nSample patient scores:\n";
    
    std::set<std::string> uniquePatients;
    for (const auto& entry : charlsonCounter.internalMap()) {
        uniquePatients.insert(entry.first);
    }
    
    int count = 0;
    for (const auto& patientId : uniquePatients) {
        if (count++ < 10) { // Show first 10 patients
            float charlsonScore = charlsonCounter.getFloat(patientId);
            float elixhauserScore = elixhauserCounter.getFloat(patientId);
            std::cout << "Patient " << patientId 
                      << ": Charlson=" << charlsonScore 
                      << ", Elixhauser=" << elixhauserScore << "\n";
        }
    }
}

int main() {
    testMedicalDictionaries();
    
    // Look for condition files in Data directory
    std::vector<std::string> condFiles;
    fs::path dataDir = "Data";
    
    if (fs::exists(dataDir) && fs::is_directory(dataDir)) {
        for (const auto& entry : fs::directory_iterator(dataDir)) {
            if (entry.is_regular_file() && 
                entry.path().filename().string().find("conditions") != std::string::npos) {
                condFiles.push_back(entry.path().string());
            }
        }
    }
    
    if (!condFiles.empty()) {
        testConditionMatching(condFiles[0]); // Test with the first condition file found
    } else {
        std::cout << "No condition files found in Data directory.\n";
    }
    
    std::cout << "\nDone!\n";
    return 0;
}


# ========================================
# File: SystemResources.cpp
# ========================================
#include "SystemResources.h"

// Minimal implementation file for SystemResources
// The main functionality is implemented inline in the header


# ========================================
# File: SystemResources.h
# ========================================
#pragma once

#ifndef SYSTEM_RESOURCES_H
#define SYSTEM_RESOURCES_H

#include <string>
#include <vector>
#include <algorithm>
#include <utility>

// Simple class to avoid the syntax errors
class SystemResources {
public:
    static double getSystemMemoryUsageMB() {
        return 1000.0; // Default implementation
    }
    
    static double getSystemMemorySizeMB() {
        return 8192.0; // Default implementation
    }
    
    static double getSystemCpuUsage() {
        return 25.0; // Default implementation
    }
    
    static int getSystemCoreCount() {
        return 4; // Default implementation
    }
};

#endif // SYSTEM_RESOURCES_H


# ========================================
# File: ThreadPool.cpp
# ========================================
#include "ThreadPool.h"
#include "Utilities.h"

ThreadPool::ThreadPool(size_t threads) : stop(false) {
    for(size_t i = 0; i < threads; ++i)
        workers.emplace_back([this] {
            while(true) {
                std::function<void()> task;
                
                {
                    std::unique_lock<std::mutex> lock(this->queue_mutex);
                    this->condition.wait(lock, [this] { 
                        return this->stop || !this->tasks.empty(); 
                    });
                    
                    if(this->stop && this->tasks.empty())
                        return;
                    
                    task = std::move(this->tasks.front());
                    this->tasks.pop();
                }
                
                task();
            }
        });
}

ThreadPool::~ThreadPool() {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    
    condition.notify_all();
    
    for(std::thread &worker: workers)
        worker.join();
}

// Implement the enqueue function in the header since it's a template function


# ========================================
# File: ThreadPool.h
# ========================================
#pragma once

#ifndef THREAD_POOL_H
#define THREAD_POOL_H

#include <functional>
#include <vector>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <future>

class ThreadPool {
public:
    ThreadPool(size_t threads);
    ~ThreadPool();
    
    template<class F, class... Args>
    auto enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> {
        using return_type = typename std::result_of<F(Args...)>::type;

        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
        );
            
        std::future<return_type> res = task->get_future();
        {
            std::unique_lock<std::mutex> lock(queue_mutex);

            // Don't allow enqueueing after stopping the pool
            if(stop) {
                throw std::runtime_error("enqueue on stopped ThreadPool");
            }

            tasks.emplace([task](){ (*task)(); });
        }
        condition.notify_one();
        return res;
    }
    
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};

#endif // THREAD_POOL_H


# ========================================
# File: ThreadSafeCounter.h
# ========================================
#pragma once

#include <unordered_map>
#include <shared_mutex>
#include <mutex>
#include <string>
#include <atomic>
#include <vector>
#include <thread>
#include <memory>

// A thread-safe counter optimized for high-concurrency scenarios
class ThreadSafeCounter {
private:
    class Shard {
    public:
        std::shared_mutex mutex;
        std::unordered_map<std::string, float> counters;
        std::unordered_map<std::string, uint16_t> intCounters;
        
        // Add move constructor to allow unique_ptr to work with this class
        Shard() = default;
        Shard(Shard&&) noexcept = default;
        Shard& operator=(Shard&&) noexcept = default;
        
        // Delete copy operations since shared_mutex is not copyable
        Shard(const Shard&) = delete;
        Shard& operator=(const Shard&) = delete;
    };
    
    // Change vector to store unique_ptr to Shard
    std::vector<std::unique_ptr<Shard>> shards;
    size_t numShards;
    
    // Hash function to distribute keys across shards
    size_t getShard(const std::string& key) const {
        std::hash<std::string> hasher;
        return hasher(key) % numShards;
    }

public:
    // Auto-scale shard count based on hardware
    ThreadSafeCounter(size_t shardCount = 0) {
        // If shardCount is 0, auto-scale based on hardware
        if (shardCount == 0) {
            unsigned int cpuCount = std::thread::hardware_concurrency();
            numShards = cpuCount * 8; // Much more aggressive sharding - 8x CPU count
            numShards = std::max<size_t>(32, numShards); // Minimum 32 shards for better distribution
        } else {
            numShards = shardCount;
        }
        
        // Initialize shards with unique_ptr
        shards.resize(numShards);
        for (size_t i = 0; i < numShards; i++) {
            shards[i] = std::make_unique<Shard>();
        }
    }
    
    // Optimized increment using reader-writer locks more efficiently
    void increment(const std::string& key) {
        size_t shardIdx = getShard(key);
        std::unique_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        shards[shardIdx]->counters[key] += 1.0f;
    }
    
    // Optimized add with hint for initial capacity to reduce rehashing
    void add(const std::string& key, float value) {
        size_t shardIdx = getShard(key);
        std::unique_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        shards[shardIdx]->counters[key] += value;
    }
    
    void add(const std::string& key, uint16_t value) {
        size_t shardIdx = getShard(key);
        std::unique_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        shards[shardIdx]->intCounters[key] += value;
    }

    void addInt(const std::string& key, uint16_t value) {
        size_t shardIdx = getShard(key);
        std::unique_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        shards[shardIdx]->intCounters[key] += value;
    }

    void addFloat(const std::string& key, float value) {
        size_t shardIdx = getShard(key);
        std::unique_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        shards[shardIdx]->counters[key] += value;
    }
    
    float getFloat(const std::string& key) const {
        size_t shardIdx = getShard(key);
        std::shared_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        auto it = shards[shardIdx]->counters.find(key);
        if (it != shards[shardIdx]->counters.end()) {
            return it->second;
        }
        return 0.0f;
    }
    
    uint16_t getInt(const std::string& key) const {
        size_t shardIdx = getShard(key);
        std::shared_lock<std::shared_mutex> lock(shards[shardIdx]->mutex);
        auto it = shards[shardIdx]->intCounters.find(key);
        if (it != shards[shardIdx]->intCounters.end()) {
            return it->second;
        }
        return 0;
    }
    
    // Optimized bulk add with better locking strategy
    void bulkAdd(const std::unordered_map<std::string, float>& updates) {
        // Pre-sort updates by shard for more efficient processing
        std::vector<std::unordered_map<std::string, float>> shardUpdates(numShards);
        
        // First pass: group by shard without locking
        for (const auto& [key, value] : updates) {
            size_t shardIdx = getShard(key);
            shardUpdates[shardIdx][key] = value;
        }
        
        // Second pass: acquire locks only for shards that have updates
        #pragma omp parallel for if(numShards > 16) // Use OpenMP if many shards
        for (size_t i = 0; i < numShards; i++) {
            if (!shardUpdates[i].empty()) {
                std::unique_lock<std::shared_mutex> lock(shards[i]->mutex);
                for (const auto& [key, value] : shardUpdates[i]) {
                    shards[i]->counters[key] += value;
                }
            }
        }
    }
    
    // More aggressive pre-allocation
    void reserve(size_t expectedEntries) {
        // Calculate per-shard capacity with extra headroom for better distribution
        size_t entriesPerShard = (expectedEntries + numShards - 1) / numShards;
        entriesPerShard = static_cast<size_t>(entriesPerShard * 1.5); // Add 50% extra capacity
        
        #pragma omp parallel for if(numShards > 16) // Parallelize reservation
        for (size_t i = 0; i < numShards; i++) {
            std::unique_lock<std::shared_mutex> lock(shards[i]->mutex);
            shards[i]->counters.reserve(entriesPerShard);
            shards[i]->intCounters.reserve(entriesPerShard);
        }
    }
};


# ========================================
# File: ThreadSafeCounterDebug.cpp
# ========================================
#include <iostream>
#include <string>
#include <map>
#include "DataStructures.h"

// Add method to ThreadSafeCounter class in DataStructures.h:
// Add this to the public section:
// const std::unordered_map<std::string, int>& internalMap() const { return intCounts; }
// const std::unordered_map<std::string, float>& internalFloatMap() const { return floatCounts; }

void testThreadSafeCounter() {
    ThreadSafeCounter counter;
    
    // Test integer counts
    std::cout << "Testing integer counts:\n";
    counter.increment("patient1", 1);
    counter.increment("patient1", 2);
    counter.increment("patient2", 1);
    
    std::cout << "patient1 count: " << counter.getInt("patient1") << " (expected 3)\n";
    std::cout << "patient2 count: " << counter.getInt("patient2") << " (expected 1)\n";
    std::cout << "patient3 count: " << counter.getInt("patient3") << " (expected 0)\n";
    
    // Test float counts
    std::cout << "\nTesting float counts:\n";
    counter.addFloat("patient1", 1.5f);
    counter.addFloat("patient1", 2.5f);
    counter.addFloat("patient2", 0.5f);
    
    std::cout << "patient1 float: " << counter.getFloat("patient1") << " (expected 4.0)\n";
    std::cout << "patient2 float: " << counter.getFloat("patient2") << " (expected 0.5)\n";
    std::cout << "patient3 float: " << counter.getFloat("patient3") << " (expected 0)\n";
    
    // Test map access
    std::cout << "\nDumping full counter contents:\n";
    std::cout << "Integer counts:\n";
    for (const auto& entry : counter.internalMap()) {
        std::cout << "  " << entry.first << ": " << entry.second << "\n";
    }
    
    std::cout << "Float counts:\n";
    for (const auto& entry : counter.internalFloatMap()) {
        std::cout << "  " << entry.first << ": " << entry.second << "\n";
    }
}

int main() {
    std::cout << "=== Testing ThreadSafeCounter Class ===\n";
    testThreadSafeCounter();
    std::cout << "Done!\n";
    return 0;
}


# ========================================
# File: Utilities.cpp
# ========================================
#include "DataStructures.h" // Added this include for data type definitions
#include "Utilities.h"
#include <iostream>
#include <filesystem>
#include <vector>
#include <string>
#include <cstdlib>
#include <unordered_map>
#include <functional>
#include <set>
#include <sstream>  // Add this include for std::ostringstream

namespace fs = std::filesystem;

// Initialize global variables with EXACT signatures needed by GenerateAndPredict.cpp
unsigned int const DEFAULT_THREAD_COUNT = 4;  // Changed order to match the reference
bool GPU_INFERENCE_FAILED = false;
size_t DEFAULT_CSV_BATCH_SIZE = 1000;
bool PERFORMANCE_MODE = false;
bool EXTREME_PERFORMANCE = false;
const std::string DATA_DIR = "Data";
const std::string SYN_DIR  = "synthea-master";
const std::string SYN_OUT  = "output/csv";
float memoryUtilTarget = 0.7f;
float cpuUtilTarget = 0.8f;

// Medical dictionaries - these are defined as extern in MedicalDictionaries.h
std::unordered_map<std::string, float> CHARLSON_CODE_TO_WEIGHT_INTERNAL = {
    {"diabetes", 1.0f},
    {"heart_failure", 1.0f},
    {"copd", 1.0f},
    // Make sure to include all codes needed in GenerateAndPredict.cpp
    {"E11.9", 1.0f},    // Type 2 diabetes without complications
    {"I10", 0.5f},      // Essential (primary) hypertension
    {"J44.9", 1.0f}     // COPD
    // Add other codes as needed
};

std::unordered_map<std::string, float> ELIXHAUSER_CODE_TO_WEIGHT_INTERNAL = {
    {"diabetes", 0.5f},
    {"heart_failure", 1.5f},
    {"hypertension", 0.7f},
    // Make sure to include all codes needed in GenerateAndPredict.cpp
    {"E11.9", 0.7f},    // Type 2 diabetes without complications
    {"I10", 0.3f},      // Essential (primary) hypertension
    {"J44.9", 0.9f}     // COPD
    // Add other codes as needed
};

void makeDirIfNeeded(const std::string &dir) {
    if (!fs::exists(dir)) {
        fs::create_directories(dir);
    }
}

std::string getTimestamp() {
    time_t rawtime;
    struct tm timeinfo;
    time(&rawtime);
#ifdef _WIN32
    localtime_s(&timeinfo, &rawtime);
#else
    localtime_r(&timeinfo, &rawtime);
#endif
    char buffer[30];
    strftime(buffer, sizeof(buffer), "%Y%m%d_%H%M%S", &timeinfo);
    return std::string(buffer);
}

void runSynthea(int popSize) {
#ifdef _WIN32
    std::string cmd = "cd " + SYN_DIR + " && run_synthea.bat -p " + std::to_string(popSize);
#else
    std::string cmd = "cd " + SYN_DIR + " && ./run_synthea -p " + std::to_string(popSize);
#endif
    std::cout << "[INFO] Running Synthea: " << cmd << "\n";
    int ret = std::system(cmd.c_str());
    if (ret != 0) {
        std::cerr << "[ERROR] Synthea generation failed.\n";
        std::exit(1);
    }
    std::cout << "[INFO] Synthea generation complete.\n";
}

bool isDiffFile(const std::string &fname) {
    return (fname.find("_diff_") != std::string::npos);
}

void copySyntheaOutput() {
    fs::path synOutput = fs::path(SYN_DIR) / SYN_OUT;
    if (!fs::exists(synOutput)) {
        std::cerr << "[ERROR] Synthea output dir " << synOutput << " not found.\n";
        std::exit(1);
    }
    makeDirIfNeeded(DATA_DIR);
    std::vector<std::string> needed = {
        "patients.csv", "encounters.csv", "conditions.csv",
        "medications.csv", "observations.csv", "procedures.csv"
    };
    std::string stamp = getTimestamp();
    for (auto &fname : needed) {
        fs::path src = synOutput / fname;
        if (!fs::exists(src)) {
            std::cerr << "[WARN] Missing " << fname << " in Synthea output.\n";
            continue;
        }
        auto dotPos = fname.rfind('.');
        std::string base = (dotPos == std::string::npos) ? fname : fname.substr(0, dotPos);
        std::string ext  = (dotPos == std::string::npos) ? "" : fname.substr(dotPos);
        std::string newName = base + "_diff_" + stamp + ext;
        fs::path dst = fs::path(DATA_DIR) / newName;
        std::cout << "[INFO] Copying " << src << " => " << dst << "\n";
        try {
            fs::copy_file(src, dst, fs::copy_options::overwrite_existing);
        } catch (const fs::filesystem_error &ex) {
            std::cerr << "[ERROR] copy failed: " << ex.what() << "\n";
        }
    }
}

// REMOVE DUPLICATED FUNCTIONS
// These are already defined in other files, so we'll just declare them here
// but not implement them

// Declare FileProcessing.cpp functions
extern std::vector<std::string> listCSVFiles(const std::string &prefix);
extern void processPatientsInBatches(const std::string& filename, std::function<void(const PatientRecord&)> processor);
extern void processConditionsInBatches(const std::string& filename, std::function<void(const ConditionRow&)> processor);
extern void processEncountersInBatches(const std::string& filename, std::function<void(const EncounterRow&)> processor);
extern void processMedicationsInBatches(const std::string& filename, std::function<void(const MedicationRow&)> processor);
extern void processObservationsInBatches(const std::string& filename, std::function<void(const ObservationRow&)> processor);

// Declare PatientSubsets.cpp functions
extern std::set<std::string> findPatientSubset(const std::string& condition, const std::vector<ConditionRow>& conditions);

// Declare FeatureUtils.cpp functions
extern std::vector<std::string> getFeatureCols(const std::string& featureConfig);
extern void writeFeaturesCSV(const std::vector<PatientRecord>& patients, 
                      const std::string& outputFile,
                      const std::vector<std::string>& featureCols);
extern void saveFinalDataCSV(const std::vector<PatientRecord>& patients, 
                     const std::string& outputFile);

// Declare HealthIndex.cpp functions
extern float computeHealthIndex(const PatientRecord& patient);

// Empty stubs for calling the actual MedicalDictionaries.h implementations
void initializeDirectLookupsCaller() {
    // Call the implementation from MedicalDictionaries.h
    initializeDirectLookups();
}

void initializeObsAbnormalDirectCaller() {
    // Call the implementation from MedicalDictionaries.h
    initializeObsAbnormalDirect();
}


# ========================================
# File: Utilities.h
# ========================================
#pragma once

#include <string>
#include <vector>
#include <functional>
#include <set>
#include <unordered_map>
#include <ctime>
#include <iostream>
#include <filesystem>

namespace fs = std::filesystem;

// Forward declarations
struct PatientRecord;
struct ConditionRow;
struct EncounterRow;
struct MedicationRow;
struct ObservationRow;

// Global variables
extern const unsigned int DEFAULT_THREAD_COUNT;
extern unsigned int THREAD_COUNT;
extern bool GPU_INFERENCE_FAILED;
extern size_t DEFAULT_CSV_BATCH_SIZE;
extern bool PERFORMANCE_MODE;
extern bool EXTREME_PERFORMANCE;
extern const std::string DATA_DIR;
extern const std::string SYN_DIR;
extern const std::string SYN_OUT;
extern float memoryUtilTarget;
extern float cpuUtilTarget;

// Use MedicalDictionaries.h for dictionary declarations
#include "MedicalDictionaries.h"

// Utility function declarations
void makeDirIfNeeded(const std::string &dir);
std::string getTimestamp();
void runSynthea(int popSize);
bool isDiffFile(const std::string &fname);
void copySyntheaOutput();
std::vector<std::string> listCSVFiles(const std::string &prefix);

void processPatientsInBatches(const std::string& filename, 
                              std::function<void(const PatientRecord&)> processor);
void processConditionsInBatches(const std::string& filename, 
                               std::function<void(const ConditionRow&)> processor);
void processEncountersInBatches(const std::string& filename, 
                               std::function<void(const EncounterRow&)> processor);
void processMedicationsInBatches(const std::string& filename, 
                                std::function<void(const MedicationRow&)> processor);
void processObservationsInBatches(const std::string& filename, 
                                 std::function<void(const ObservationRow&)> processor);

std::set<std::string> findPatientSubset(const std::string& condition, 
                                       const std::vector<ConditionRow>& conditions);
double findGroupWeightFast(const std::string& code);
bool isAbnormalObsFast(const std::string& description, double value);

std::vector<std::string> getFeatureCols(const std::string& featureConfig);
void writeFeaturesCSV(const std::vector<PatientRecord>& patients, 
                      const std::string& outputFile,
                      const std::vector<std::string>& featureCols);
void saveFinalDataCSV(const std::vector<PatientRecord>& patients, 
                     const std::string& outputFile);

float computeHealthIndex(const PatientRecord& patient);

void initializeDirectLookups();
void initializeObsAbnormalDirect();

// Validate feature CSV for model compatibility
bool validateFeatureCSV(const std::string& csvPath);
